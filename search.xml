<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Benchmark</title>
    <url>/2025/01/15/Benchmark/</url>
    <content><![CDATA[<h3 id="2025-01英语水平记录"><a href="#2025-01英语水平记录" class="headerlink" title="2025-01英语水平记录"></a>2025-01英语水平记录</h3><p>使用单词量测试工具 <a href="http://testyourvocab.com/">http://testyourvocab.com/</a>  测试出来的单词量有4331</p>
<p>接下来我准备看词缀词根记忆法来记忆单词  </p>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer_composition_principles01</title>
    <url>/2024/12/11/Computer_composition_principles01/</url>
    <content><![CDATA[<p><strong>这篇是跟着课程记的笔记，比较乱！！！！</strong></p>
<p>速度快的都是使用北桥芯片进行连接  gpu 内存   cpu</p>
<p>速度慢的使用南桥芯片</p>
<p>cpu处理计算机指令的</p>
<p>C++ 大小写敏感；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\\&quot;</span>   \</span><br><span class="line"><span class="string">&quot;\&quot;&quot;</span>   <span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>\<span class="string">&#x27;&quot;   &#x27;</span> </span><br><span class="line"><span class="string">&quot;\n&quot;</span>   换行</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);     </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);   <span class="comment">//开始 + R  暂停</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;shutdown&quot;</span>);  <span class="comment">//关机</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在双引号里面要用俩反斜杠才行</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;C:\\...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;color 13&quot;</span>);  <span class="comment">//设置控制台颜色</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;mode con cols = 80 lines = 40&quot;</span>); <span class="comment">//控制窗口大小</span></span><br></pre></td></tr></table></figure>

<p>编程的本质就是程序员和计算机沟通的过程</p>
<p>进制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">十进制   99  10&#x27;250</span><br><span class="line">二进制   0b11   0b11111</span><br><span class="line">八进制   011</span><br><span class="line">十六进制 0xf1  0xFE</span><br></pre></td></tr></table></figure>

<p>变量定义方式</p>
<p>类型 名字{初始值}    or    类型  名字 &#x3D; 初始值</p>
<p>const 类型  名字 {初始值}；  类型  const 名字  {初始值}</p>
<p>不管是常量还是变量，本质上都是在内存中申请一块区域，用来存放我们的数据，只不过常量申请的内存区域不允许修改，而变量申请的内存区域，允许修改。以上说的可以修改和不可以修改，只是站在编译器的角度，实际上，不管是变量还是常量，甚至是已经编译好的代码，都可以修改。</p>
<p>基本数据类型的数值范围</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20241109164312874.png" alt="image-20241109164312874"></p>
<p>float      4字节    大约7位精度  ±3.4E±38</p>
<p>double   8字节   大约15位精度±1.7E±308</p>
<p>long double 8字节  大约15位精度±1.7E±308</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">500</span>;</span><br><span class="line"><span class="type">unsigned</span> b = <span class="number">1000</span>;</span><br><span class="line">cout &lt;&lt; a - b &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>无符号数的优先级更高，所以结果是无符号数</p>
<p>500−1000&#x3D;500+(2^32−1000)&#x3D;4294966796</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">500</span>;</span><br><span class="line"><span class="type">unsigned</span> b = <span class="number">1000</span>;</span><br><span class="line">a -= b;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>结果为-500，因为a是int类型</p>
]]></content>
      <categories>
        <category>底层</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer_composition_principles02</title>
    <url>/2024/12/11/Computer_composition_principles02/</url>
    <content><![CDATA[<p><strong>程序内存的布局</strong></p>
<p>一个程序的内存空间大致可以分为以下几个区域：</p>
<ol>
<li><strong>代码段（Text Segment）</strong>：<ul>
<li>存放程序的可执行代码，即机器码。</li>
<li>这部分内存是只读的，避免程序在运行过程中修改自己的代码。</li>
</ul>
</li>
<li><strong>数据段（Data Segment）</strong>：<ul>
<li>存储全局变量、静态变量、常量等已初始化的数据。</li>
<li>数据段可以进一步分为 <strong>已初始化数据段</strong> 和 <strong>未初始化数据段</strong>（又称 BSS 段）。</li>
</ul>
</li>
<li><strong>BSS 段（Block Started by Symbol）</strong>：<ul>
<li>用于存储程序中的 <strong>未初始化的全局变量和静态变量</strong>。</li>
<li>在程序加载时，BSS 段的所有数据会被初始化为零。</li>
</ul>
</li>
<li><strong>堆（Heap）</strong>：<ul>
<li>用于动态分配内存（如 <code>new</code>、<code>malloc</code> 等），它是程序运行时申请内存的区域。</li>
<li>堆的内存由程序员手动管理，使用完后需要显式释放（如通过 <code>delete</code> 或 <code>free</code>）。</li>
</ul>
</li>
<li><strong>栈（Stack）</strong>：<ul>
<li>存储局部变量、函数调用信息、返回地址等。</li>
<li>栈的内存是自动管理的，当函数调用时会分配栈空间，函数返回时会自动释放。</li>
</ul>
</li>
<li><strong>堆栈区（Stack and Heap）</strong>：<ul>
<li>栈和堆是用于存储临时数据的区域，栈由操作系统自动管理，而堆则由程序员通过动态内存分配来管理。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>底层</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus00会议记录</title>
    <url>/2024/12/11/Cplusplus00%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="2024-11-11-第一次会议"><a href="#2024-11-11-第一次会议" class="headerlink" title="2024.11.11  第一次会议"></a>2024.11.11  第一次会议</h3><p>没有回答好的内容：</p>
<p>ASCII、Unicode编码，enum 和 enum class的区别</p>
<ol>
<li><strong>ASCII、Unicode编码</strong></li>
</ol>
<p>ASCII码使用指定的7位或者8位二进制数组合来表示128或256种可能的字符。标准的ASCII码使用7位二进制数(剩下一位二进制位0)来表示所有的大写字母和小写字母，数字0-9、标点符号，以及在美式英语中使用的特殊控制字符。最后一位用于奇偶校验。</p>
<p>ASCII是单字节编码，无法用来表示中文，所以中国制定了GB2312编码，把中文编进去。</p>
<p>Unicode：把所有的语言都统一到一套编码里面，这样就不会有乱码的问题。最常用的是用两个字节表示一个字符（偏僻的字符使用4个字节）</p>
<p>UTF8  可变长编码，把一个Unicode字符根据不同的数字大小编码成1-6字节，常用的英文字母被编码成 1个字节，汉字通常是三个字节，只有生僻字才被编码成4-6个字节。传输的文本含有大量英文，使用UTF-8编码就能节省空间。</p>
<p><img src="https://bu.dusays.com/2024/11/13/6734516268bb0.png" alt="image-20241112124850995"></p>
<p><img src="https://bu.dusays.com/2024/11/13/673451626be7b.png"></p>
<ol start="2">
<li><strong>enum 与 enum class</strong></li>
</ol>
<p>enum被称为不限定范围的枚举，enum class被称为限定范围的枚举</p>
<p>1️⃣enum是传统的枚举类型：</p>
<p>​	枚举值可以隐式转换成整数。</p>
<p>​	作用域：enum中的成员是全局的，可能导致名字冲突。两个枚举类型定义了相同的枚举变量名字，就会出现错误。</p>
<p>​	类型安全：不具备严格的类型安全，无意中与整数或其他枚举类型混用。</p>
<p>2️⃣enum class</p>
<p>​	作用域：enum class中的成员是局部与枚举类型本身的，不会造成名字冲突</p>
<p>​	显示转换：要将enum class 的成员转换成整数，必须使用static_cast</p>
<p>​	类型安全：enum class 更加安全，枚举值不会隐式转换为整数，必须显示转换</p>
<ol start="3">
<li><p>goto什么时候不能跳？</p>
<p>1️⃣跳转进入其他作用域：<code>goto</code>不能跳转到一个不同作用域的标签。例如，不能从外部作用域跳转进入一个函数内部，或从循环或条件语句外部跳入其内部。</p>
<p>2️⃣跨越对象的初始化：如果跳转会导致跨越具有非平凡析构函数的对象的初始化，则会出现编译错误。这是因为跳过对象初始化可能导致未定义行为，例如资源未正确分配。</p>
<p>3️⃣代替结构化控制语句：<code>goto</code>语句通常不应当代替<code>for</code>、<code>while</code>、<code>do-while</code>等结构化控制语句，因为这样会使代码更难理解和维护。应优先使用这些结构化的循环和分支结构。</p>
<p>4️⃣跨越内存管理代码块，在C++中，管理内存（如<code>new</code>和<code>delete</code>）时不宜使用<code>goto</code>，因为容易导致资源泄露。用<code>goto</code>跳过特定的代码可能导致内存或资源未释放。</p>
</li>
</ol>
<h3 id="2024-11-18-第二次会议"><a href="#2024-11-18-第二次会议" class="headerlink" title="2024.11.18  第二次会议"></a>2024.11.18  第二次会议</h3><p>没有回答好的问题：智能指针、左值右值</p>
<ol>
<li><strong>智能指针</strong></li>
</ol>
<p>智能指针是C++ 中用于自动管理动态内存的对象。它是一种特殊的类，通过封装普通指针的行为，实现自动资源管理（内存释放），从而避免常见的内存泄露和悬垂指针问题。</p>
<p>1️⃣ 独占型智能指针 std::unique_ptr</p>
<p>独占所有权，同一时间只能有一个std::unique_ptr管理某个资源，适用于需要明确表示所有权的场景。<strong>不可复制，但可以转移所有权</strong>。</p>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);  <span class="comment">// 分配内存并赋值</span></span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//std::unique_ptr&lt;int&gt; ptr2 = ptr1; 错误的  不允许复制</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// 转移所有权</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2️⃣ std::shared_ptr</p>
<p>共享所有权，多个std::shared_ptr可以共享同一种资源。适用于多个对象需要访问同一资源的场景。使用计数管理资源。引用计数为0时，资源才会被释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>); <span class="comment">// 分配内存 </span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 共享所有权</span></span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; *ptr2 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    ptr<span class="number">1.</span><span class="built_in">reset</span>(); <span class="comment">// 释放ptr1对资源的引用</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 is null, but ptr2 still owns the resource.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3️⃣ std::weak_ptr</p>
<p>弱引用，不参与引用计数管理。解决std::share_ptr的循环引用的问题。需要使用lock() 方法将 std::weak_ptr 转化为 std::shared_ptr来访问资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; weakPtr = sharedPtr;  <span class="comment">// 弱引用, 不增加引用计数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> lockedPtr = weakPtr.<span class="built_in">lock</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; *lockedPtr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource is no longer available.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sharedPtr.<span class="built_in">reset</span>(); <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> lockedPtr = weakPtr.<span class="built_in">lock</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; *lockedPtr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource is no longer available.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>智能指针的<strong>优点</strong>：自动释放内存， 减少new&#x2F;delete带来的麻烦。  避免内存泄露和悬垂指针问题。  代码更简洁、更安全。  <strong>用途</strong>：动态内存分配时，确保资源被独占管理且使用完成后自动释放。管理不需要共享的资源，如文件句柄、单线程对象等。</p>
<p>注意事项：</p>
<p>1️⃣ 不要同时使用普通指针和智能指针管理统一资源</p>
<p>2️⃣ std::shared_ptr 可能带来性能开销 (由于引用计数管理)。</p>
<p>3️⃣ std::weak_ptr 解决 std::shared_ptr的循环引用问题 。</p>
<p><strong>循环引用问题</strong> 是指在使用智能指针（尤其是 <code>std::shared_ptr</code>）时，由于两个或多个对象互相引用对方，导致引用计数永远无法降为零，资源无法释放，造成 <strong>内存泄漏</strong> 的问题。</p>
<ol start="2">
<li>左值和右值</li>
</ol>
<p>左值（lvalue, locator value）表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</p>
<p>右值（rvalue）则使用排除法来定义。一个表达式不是 左值 就是 右值 。那么，右值是一个 不表示内存中某个可识别位置的对象的表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var;</span><br><span class="line">var = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>赋值操作需要左操作数是一个左值。var是一个有内存位置的对象，因此它是左值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> = var;</span><br><span class="line">(var + <span class="number">1</span>) = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>常量 4 和表达式 var +  1 都不是左值，因为它们都是表达式的临时结果，而没有可识的内存位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 错误，foo返回的是一个临时的值。它是一个右值，赋值给它是错误的。</span></span><br><span class="line">    <span class="built_in">foo</span>() = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> globalvar = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> globalvar;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>() = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里foo返回一个引用。引用了一个左值，因此可以赋值给它。</p>
<p>C++ 中函数可以返回左值的功能对实现一些重载的操作符非常重要。下面是重载方括号操作符[]，来实现一些查找访问的操作，如std::map 中的方括号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, <span class="type">float</span>&gt; mymap;</span><br><span class="line">mymap[<span class="number">10</span>] = <span class="number">5.6</span>;</span><br></pre></td></tr></table></figure>

<p>之所以能赋值给mymap[10], 是因为std::map::operator[] 的重载返回的是一个可赋值的引用。</p>
<p><strong>可修改的左值</strong></p>
<p>可以出现在赋值操作左边的值，但是加入const关键字后，这个定义不再成立</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// &#x27;a&#x27; 是左值</span></span><br><span class="line">a = <span class="number">10</span>;   <span class="comment">// 但不可以赋值给它</span></span><br></pre></td></tr></table></figure>

<p>所以可赋值的左值被称为 可修改左值. C99标准定义可修改左值为:</p>
<p>可修改左值是特殊的左值，不含有数组类型、不完整类型、const 修饰的类型。如果它是 <code>struct</code> 或 <code>union</code>，它的成员都（递归地）不应含有 const 修饰的类型。</p>
<p><strong>左值与右值的转换</strong></p>
<p>左值可以转成右值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;     <span class="comment">// a 是左值</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;     <span class="comment">// b 是左值</span></span><br><span class="line"><span class="type">int</span> c = a + b; <span class="comment">// + 需要右值，所以 a 和 b 被转换成右值</span></span><br><span class="line">               <span class="comment">// + 返回右值</span></span><br></pre></td></tr></table></figure>

<p>右值不可以转成左值,因为违反了左值的本质.  但是右值可以通过显式的方法产生左值. </p>
<p>例如, 一元解引用运算符 ‘*’ 需要一个右值参数, 但返回一个左值结果. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = &amp;arr[<span class="number">0</span>];</span><br><span class="line">*(p + <span class="number">1</span>) = <span class="number">10</span>;   <span class="comment">//p + 1是右值,   但*(p + 1) 是左值</span></span><br></pre></td></tr></table></figure>

<p>相反的,一元去地址操作符’&amp;’ 需要一个左值参数,返回一个右值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* b_arr = &amp;(var + <span class="number">1</span>);  <span class="comment">// &amp;  需要左值参数</span></span><br><span class="line"><span class="type">int</span>* addr = &amp;var;    <span class="comment">// 正确,  var是左值</span></span><br><span class="line">&amp;var = <span class="number">40</span>;   <span class="comment">//错误, 赋值操作的左操作数需要的是左值</span></span><br></pre></td></tr></table></figure>

<p>‘&amp;’ 符号还有另一个功能—–定义引用类型.  引用类型又叫做”左值引用”.  因此不能将一个右值赋值给(非常量的) 左值引用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string&amp; sref = std::<span class="built_in">string</span>();  <span class="comment">// 错误: 非常量的引用 &#x27;std::string&amp;&#x27; 错误地使用右值 &#x27;std::string&#x27; 初始化</span></span><br></pre></td></tr></table></figure>

<p><em>常量的</em> 左值引用可以使用右值赋值。因为你无法通过常量的引用修改变量的值，也就不会出现修改了右值的情况。这也使得 C++ 中一个常见的习惯成为可能：函数的参数使用常量引用接收参数，避免创建不必要的临时对象。</p>
<p><strong>CV限定的右值</strong></p>
<p>一个非函数、非数组的类型 T 的左值可以转换为右值。 […] 如果 T 不是类类型【译注：类类型即 C++ 中使用类定义的类型，区别与内置类型】，转换后的右值的类型是 T 的 未限定 CV 的版本</p>
<p>每个类型都有三个对应的CV-限定类型版本: const 限定   volatile 限定 和 const-volatile 限定版本.  有或无CV限定的类型是不同的类型, 但是写法和赋值需求都是相同的.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::foo() const\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::foo()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">A</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> A <span class="title">cbar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">A</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bar</span>().<span class="built_in">foo</span>();</span><br><span class="line">    <span class="built_in">cbar</span>().<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code> 中的第二个函数调用实际上调用的是 <code>A</code> 中的 <code>foo() const</code> 函数，因为 <code>cbar</code> 返回的类型是 <code>const A</code>，这和 <code>A</code> 是两个不同的类型。这就是上面的引用中最后一句话所表达的意思。另外注意到，<code>cbar</code> 的返回值是一个右值，所以这是一个实际的 CV 限定的右值的例子。</p>
<p><strong>右值引用</strong></p>
<p>左值和右值的主要区别是，左值可以被修改，而右值不能。不过，C++11 改变了这一区别。在一些特殊的情况下，我们可以使用右值的引用，并对右值进行修改。</p>
<p>使用 <code>&amp;&amp;</code> 表示。它专门用于绑定右值，从而使程序可以操作右值（临时对象）。</p>
<p>用途: 1️⃣ 移动语义, 通过移动右值资源(如动态内存) 避免拷贝, 提升性能. 2️⃣完美转发:保留函数模板中参数的值类别(左值或右值)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str2 = std::<span class="built_in">move</span>(str1);   <span class="comment">// std::move 将 str1 转为右值</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2&quot;</span> &lt;&lt; str2 &lt;&lt; std::endl;  <span class="comment">//输出Hello</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1&quot;</span> &lt;&lt; str1 &lt;&lt; std::endl;  <span class="comment">// str1 的资源已经被转移, 可能为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://bu.dusays.com/2024/11/19/673c83b590a66.png"></p>
<p>Q: 如何判断一个表达式是左值还是右值?</p>
<p>1️⃣ 如果能取地址 (&amp; 操作符能成功) , 则为左值</p>
<p>2️⃣ 如果不能取地址, 但可以用作右侧赋值, 则为右值</p>
<p>引用右值 主要是为了支持移动语义, 以减少不必要的资源拷贝, 以提高程序效率</p>
<p>总结 :</p>
<p> 左值 : 有明确的内存位置, 生命周期可控, 可取地址.</p>
<p> 右值:  临时值, 生命周期短, 通常不可修改.</p>
<p> 右值引用：通过&amp;&amp;操作符，允许操作右值，主要用于移动语义和完美转发。</p>
<h3 id="2024-11-25-第三次会议"><a href="#2024-11-25-第三次会议" class="headerlink" title="2024.11.25 第三次会议"></a>2024.11.25 第三次会议</h3><p>没有回答好的内容： 数组指针、堆栈溢出</p>
<h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">int</span> (*p)[<span class="number">5</span>] = &amp;a;   <span class="comment">// 数组指针</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">sizeof</span>(*p));   <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a[<span class="number">0</span>]);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>p</code> 指针指向包含五个整型元素的数组指针。注意这里的<code>(*p)</code>表明<code>p</code>是一个指针，而<code>[5]</code>表示它指向的对象是一个包含5个元素的数组。并且将 <code>p</code> 初始化为指向前面定义的数组 <code>a</code> 的地址（通过 <code>&amp;a</code> 取数组 <code>a</code> 的地址来赋值给 <code>p</code>）</p>
<p>在这里，<code>*p</code> 实际上就是 <code>p</code> 所指向的那个包含 5 个整型元素的数组（因为 <code>p</code> 是指向数组的指针，解引用 <code>*p</code> 就得到它指向的数组本身）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p><code>printf(&quot;%p\n&quot;, a);</code>：这里输出数组 <code>a</code> 的首元素地址，前面提到数组名在很多情况下可以代表首元素地址，所以它会输出数组 <code>a</code> 第一个元素在内存中的地址。</p>
<p><code>printf(&quot;%p\n&quot;, &amp;a);</code>：这里通过 <code>&amp;a</code> 取的是整个数组 <code>a</code> 的地址，虽然数组首元素地址的值和整个数组的地址的值在数值上通常是一样的（在绝大多数常见的实现中），但它们的类型是不同的，一个是指向数组首元素的指针（<code>int*</code> 类型的指针），另一个是指向整个数组的指针（<code>int (*)[5]</code> 类型的指针）。</p>
<p><code>printf(&quot;%p\n&quot;, &amp;a[0]);</code>：这是取数组 <code>a</code> 的首元素 <code>a[0]</code> 的地址，其效果和直接使用 <code>a</code> （在代表首元素地址这个意义上）是一样的，同样会输出数组 <code>a</code> 第一个元素在内存中的地址。</p>
<h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a[<span class="number">5</span>]&#123; &#125;;  <span class="comment">// 指针数组  包含5个元素，每个元素的类型都是int* </span></span><br><span class="line">	<span class="type">int</span>** p = a;   <span class="comment">// </span></span><br><span class="line">	<span class="type">int</span>* (*p)[<span class="number">5</span>] = &amp;a;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了一个名为 <code>a</code> 的数组，它包含 5 个元素，每个元素的类型都是 <code>int*</code>，也就是指向整型的指针类型。通过使用初始化列表 <code>&#123; &#125;</code>，将这 5 个指针元素初始化为空指针（默认初始值）。本质上，<code>a</code> 是一个可以存放 5 个指向整型变量的指针的数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>** p = a;</span><br></pre></td></tr></table></figure>

<p>二级指针初始化为<code>a</code>。之所以能这样赋值，是因为数组名 <code>a</code> 在这种情况下会隐式转换为指向数组首元素的指针， 而 <code>a</code> 的首元素类型是 <code>int*</code> ，所以 <code>p</code> 这个二级指针就可以指向 <code>a</code> 数组 （或者说指向 <code>a</code> 数组的首元素，首元素本身也是指针类型）。这意味着通过 <code>p</code> 可以间接操作 <code>a</code> 数组中的指针元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* (*p)[<span class="number">5</span>] = &amp;a;</span><br></pre></td></tr></table></figure>

<p><code>int* (*p)[5]</code> 表示 <code>p</code> 是一个指针，它指向的是一个包含5个元素的数组，而这个数组中每个元素类型又是 <code>int*</code></p>
<p>（指向整型的指针）。然后通过 <code>&amp;a</code> 将 <code>p</code> 初始化为指向前面定义的 <code>a</code> 数组的地址。</p>
]]></content>
      <categories>
        <category>会议内容记录</category>
      </categories>
      <tags>
        <tag>会议</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus01数组、容器指针</title>
    <url>/2024/12/11/Cplusplus01%E6%95%B0%E7%BB%84%E3%80%81%E5%AE%B9%E5%99%A8%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p><strong>数组</strong>：</p>
<p>std::array中，可以通过at()来访问数组的内容，如果越界了就会抛出越界异常 </p>
<p>数组安全：由于数组的本质是向操作系统申请了一块内存，因此越界的数组将会访问到不该访问的地址，这种越界将会造成程序崩溃，BUG错误，更可怕的是，数组越界漏洞，可能会让攻击者拿到操作系统的控制权。</p>
<p><strong>容器</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;数据类型&gt; 变量名;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; s&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// 设置了5个大小的容器</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">5</span>,<span class="number">100</span>)</span></span>;  <span class="comment">// 这个容器拥有五个元素，每个元素的初始值为100</span></span><br></pre></td></tr></table></figure>

<p>容器的几个新用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">push_back</span>(值);  <span class="comment">//将值添加到容器末尾</span></span><br><span class="line">s.<span class="built_in">pop_back</span>(值);  <span class="comment">//将末尾的值删除掉</span></span><br><span class="line">s.<span class="built_in">insert</span>(); <span class="comment">// 在指定位置插入元素</span></span><br><span class="line">s.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="number">100</span>); <span class="comment">//将s重新初始化为拥有10个元素  每个元素位100的容器</span></span><br><span class="line">s.<span class="built_in">erase</span>();   <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">s.<span class="built_in">clear</span>(); <span class="comment">// 将容器清空</span></span><br><span class="line">s.<span class="built_in">empty</span>(); <span class="comment">//看看是不是空的</span></span><br></pre></td></tr></table></figure>

<p><strong>容器例子</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector 遍历</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出元素值</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">// 使用引用避免拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; vec = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; name : vec) &#123;  <span class="comment">// 使用引用避免拷贝</span></span><br><span class="line">        name += <span class="string">&quot; (modified)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; name : vec) &#123;  <span class="comment">// 使用常量引用只读访问</span></span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 map 容器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; m = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>&#125;, &#123;<span class="string">&quot;Eve&quot;</span>, <span class="number">35</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : m) &#123;  <span class="comment">// 使用结构化绑定</span></span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历unordered_map</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; um = &#123;&#123;<span class="string">&quot;One&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : um) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结构化绑定</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// std::pair  通过first second 来访问pair成员</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::pair&lt;<span class="type">int</span>, std::string&gt; p = &#123;<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构化绑定</span></span><br><span class="line">    <span class="keyword">auto</span> [id, name] = p;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 输出  ID: 1, Name: Alice</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// std::tuple</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; t = &#123;<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构化绑定</span></span><br><span class="line">    <span class="keyword">auto</span> [a, b, c] = t;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历std::map</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; m = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;, &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : m) &#123;  <span class="comment">// 解构键值对</span></span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = arr;  <span class="comment">// 解构数组</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解构用户自定义类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p = &#123;<span class="number">101</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">75000.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [id, name, salary] = p;  <span class="comment">// 解构绑定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Salary: &quot;</span> &lt;&lt; salary &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特殊应用：非聚合类型（涉及重载）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> i, std::string n, <span class="type">double</span> s) : <span class="built_in">id</span>(i), <span class="built_in">name</span>(n), <span class="built_in">salary</span>(s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">std</span>::tuple_size&lt;Person&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">auto</span> std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(<span class="type">const</span> Person&amp;) -&gt; <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">auto</span> std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(<span class="type">const</span> Person&amp;) -&gt; std::string;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">auto</span> std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(<span class="type">const</span> Person&amp;) -&gt; <span class="type">double</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化 std::tuple_size 和 std::get</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_size</span>&lt;Person&gt; : std::integral_constant&lt;<span class="type">size_t</span>, <span class="number">3</span>&gt; &#123;&#125;;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="keyword">auto</span> <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(<span class="type">const</span> Person&amp; p) &#123; <span class="keyword">return</span> p.id; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="keyword">auto</span> <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(<span class="type">const</span> Person&amp; p) &#123; <span class="keyword">return</span> p.name; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="keyword">auto</span> <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(<span class="type">const</span> Person&amp; p) &#123; <span class="keyword">return</span> p.salary; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">101</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">85000.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [id, name, salary] = p;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Salary: &quot;</span> &lt;&lt; salary &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://bu.dusays.com/2024/11/18/673ab200dc43b.png"></p>
<p><strong>指针</strong></p>
<p> 指针语法：数据类型 * 变量名称</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指针必须初始化  指针其实就是存储的别的变量的内存地址</span></span><br><span class="line"><span class="type">int</span>* a;  <span class="comment">//指针是内存地址  建议第一种写法</span></span><br><span class="line"><span class="type">int</span> *b;  <span class="comment">//两种写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要操作的内存地址</span></span><br><span class="line"><span class="comment">// 要操作的内存大小</span></span><br><span class="line"><span class="type">int</span>* pa = &amp;a;</span><br></pre></td></tr></table></figure>

<p><strong>指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[]&#123; <span class="number">10001</span>,<span class="number">20001</span>,<span class="number">30001</span>,<span class="number">40001</span> &#125;;</span><br><span class="line"><span class="type">int</span>* ptr&#123; &amp;a[<span class="number">0</span>] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针+1是 1 * 数据类型的大小</span></span><br><span class="line">std::cout &lt;&lt; ptr &lt;&lt; std::endl;			<span class="comment">//ptr的值就是a[0]的地址</span></span><br><span class="line">std::cout &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; *ptr &lt;&lt; std::endl;			<span class="comment">//*ptr就是a[0]的值</span></span><br><span class="line">std::cout &lt;&lt; (*ptr)++ &lt;&lt; std::endl;		<span class="comment">//先输出*ptr的值  为10001，然后对*ptr  加  1</span></span><br><span class="line">std::cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;  		<span class="comment">// a[0]变为10002</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;------------分界线----------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ptr &lt;&lt; std::endl;			<span class="comment">//ptr的值就是a[0]的地址</span></span><br><span class="line">std::cout &lt;&lt; *ptr++ &lt;&lt; std::endl;		<span class="comment">//++的优先级高，先对ptr++，在对ptr做解引用的操作</span></span><br><span class="line">std::cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;			<span class="comment">// a[0]的值不变</span></span><br><span class="line">std::cout &lt;&lt; *ptr &lt;&lt; std::endl;			<span class="comment">//ptr进行加一操作之后，指向a[1],  输出20001</span></span><br><span class="line">std::cout &lt;&lt; ptr &lt;&lt; std::endl;			<span class="comment">//ptr的值增加了一个int类型的大小，4个字节</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;------------分界线----------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的指针，指针也是个变量，本身也有地址，现在要操作ptr的内存</span></span><br><span class="line"><span class="comment">//不考虑前面进行的操作</span></span><br><span class="line"><span class="type">int</span>** pptr&#123; &amp;ptr &#125;;										<span class="comment">//这样定义就是指针的指针</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;数组a[0]的地址为： &quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;数组a[0]的地址为： &quot;</span> &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; std::endl;	<span class="comment">//	这里ptr和&amp;a[0]输出的相同</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ptr的地址为：&quot;</span> &lt;&lt; pptr &lt;&lt; std::endl;		<span class="comment">//这里输出ptr的地址</span></span><br><span class="line">std::cout &lt;&lt; *pptr &lt;&lt; std::endl;			<span class="comment">//*pptr解引用pptr，得到ptr的值，即a[0]地址</span></span><br><span class="line">std::cout &lt;&lt; **pptr &lt;&lt; std::endl;		<span class="comment">//**pptr进一步解引用，得到a[0]的值</span></span><br><span class="line"></span><br><span class="line">*pptr = &amp;a[<span class="number">1</span>];</span><br><span class="line">std::cout &lt;&lt; *pptr &lt;&lt; std::endl;		<span class="comment">//使用*pptr把ptr的值改成a[1]数组的内存地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//类似的，可以定义下面这种</span></span><br><span class="line"><span class="type">int</span>*** ppptr&#123; &amp;pptr &#125;;</span><br><span class="line">std::cout &lt;&lt; ***ppptr &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;------------分界线----------------&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p><img src="https://bu.dusays.com/2024/11/13/6734530db4262.png"></p>
<p><strong>常量指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const 变量类型*  只能指向一个常量</span></span><br><span class="line"><span class="comment">// 特点，指针的指向可以修改，但是指针指向的值不可以修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">int</span> c&#123; <span class="number">300</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p&#123; &amp;a &#125;;</span><br><span class="line"><span class="comment">// *p = 500;  不可以修改值</span></span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">p = &amp;b;  <span class="comment">// 可以修改指向</span></span><br><span class="line">p = &amp;c;  <span class="comment">// 常量指针也可以指向非常量变量</span></span><br><span class="line"><span class="comment">// *p = 2000;  常量指针就是不让改</span></span><br></pre></td></tr></table></figure>

<p><strong>指针常量</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//特点：指针的指向不可以改，指针指向的值可以改（内存中的数据可以更改）</span></span><br><span class="line"><span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p&#123; &amp;a &#125;;</span><br><span class="line"><span class="comment">//p = &amp;b;   不能修改指向</span></span><br><span class="line">*p = <span class="number">999</span>;  <span class="comment">//可以修改指针指向的内存空间</span></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl; <span class="comment">//  这时候a输出 999；</span></span><br></pre></td></tr></table></figure>

<p><strong>指向常量的常量指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const 变量类型* const</span></span><br><span class="line"><span class="comment">//特点：指针的指向和指针指向的值都不可以修改 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p&#123; &amp;a &#125;;</span><br><span class="line"><span class="comment">//p = &amp;b;  不能修改指向</span></span><br><span class="line"><span class="comment">//*p = 999;  不能修改内存空间里面的值</span></span><br></pre></td></tr></table></figure>

<p><strong>补充（指针有关的类型转换 ）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="comment">//int* pa&#123; &amp;a &#125;;   常量</span></span><br><span class="line"><span class="type">int</span>* pa&#123; (<span class="type">int</span>*)&amp;a &#125;;   <span class="comment">//通过转换是可以的</span></span><br><span class="line">*p = <span class="number">9500</span>;	<span class="comment">//这种操作是允许的，但是a的值不变</span></span><br><span class="line">std::cout &lt;&lt; *pa &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p><strong>指针数组补充</strong></p>
<p>指针数组是<strong>一个数组</strong>，数组的每个元素都是指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p> p 是一个包含5个指针的数组。  每个指针可以指向一个int类型的变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span>* p[<span class="number">3</span>];</span><br><span class="line">p[<span class="number">0</span>] = &amp;a;</span><br><span class="line">p[<span class="number">1</span>] = &amp;b;</span><br><span class="line">p[<span class="number">2</span>] = &amp;c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针数组来访问变量。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, c = %d&quot;</span>, *p[<span class="number">0</span>], *p[<span class="number">1</span>], *p[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// p[0] 是第一个指针， *p[0] 则访问指针指向的内容。</span></span><br></pre></td></tr></table></figure>

<p>数组指针 是<strong>一个指针</strong>，它指向一个数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>p 是一个指针，指向包含5个整型元素的数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">5</span>];</span><br><span class="line">p = &amp;a;   <span class="comment">// p 指向 数组 a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样来访问数组 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;First element: %d\n&quot;</span>, (*p)[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Second element: %d\n&quot;</span>, (*p)[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>数组指针是一个指针，它指向整个数组。</p>
<p>使用*p 解引用数组指针，可以获得数组本身， 然后可以通过下标操作访问数组元素。</p>
<p>数组指针在多维数组操作中非常常用。  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span>* ptrA&#123; a &#125;;</span><br><span class="line"><span class="type">int</span>* ptrB&#123; &amp;a[<span class="number">0</span>] &#125;;   <span class="comment">//从汇编语言得出，a放的就是a[0]的地址</span></span><br><span class="line"><span class="type">int</span>* ptrC&#123; a + <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ptrC[<span class="number">1</span>] &lt;&lt; std::endl;  <span class="comment">//输出的 是3</span></span><br><span class="line">std::cout &lt;&lt; ptrA[<span class="number">1</span>] &lt;&lt; std::endl;  <span class="comment">//也可以这样访问a[1]</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt;std::endl;  <span class="comment">//输出大小是20  处理a的时候把它当作数组处理</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(ptrA) &lt;&lt;std::endl; <span class="comment">//输出大小是4</span></span><br><span class="line"><span class="comment">//底层来说a是个指针，明面上还是数组</span></span><br><span class="line"><span class="comment">//指针可以当数组来用，数组可以当指针来读</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多维数组在内存中不存在，只是我们告诉内存这么访问而已</span></span><br><span class="line"><span class="type">int</span> test[<span class="number">2</span>][<span class="number">5</span>]</span><br><span class="line">&#123;</span><br><span class="line">	&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>,<span class="number">1005</span>&#125;,</span><br><span class="line">	&#123;<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2003</span>,<span class="number">2004</span>,<span class="number">2005</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span>* ptest&#123; (<span class="type">int</span>*)test &#125;;</span><br><span class="line">std::cout &lt;&lt; test[<span class="number">1</span>][<span class="number">4</span>] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; ptest[<span class="number">9</span>] &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> test[<span class="number">2</span>][<span class="number">5</span>]</span><br><span class="line">&#123;</span><br><span class="line">	&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>,<span class="number">1005</span>&#125;,</span><br><span class="line">	&#123;<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2003</span>,<span class="number">2004</span>,<span class="number">2005</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* ptestA[<span class="number">5</span>]; 	<span class="comment">//  指针数组，  5个int类型的指针</span></span><br><span class="line"><span class="built_in">int</span> (*ptest)[<span class="number">5</span>]&#123;test&#125;;	<span class="comment">//  首先是一个指针，类型是数组指针，每一行能存储5个数据</span></span><br><span class="line">ptest = ptest + <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; ptest &lt;&lt; std::endl; <span class="comment">//比原来增加了6 * int 的大小，因为ptest是个数组指针，逻辑是6</span></span><br><span class="line">std::cout &lt;&lt; ptest[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; std::endl; <span class="comment">//数组指针可以使用二维数组的方式访问数据</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(ptest) &lt;&lt; std::endl;  <span class="comment">//大小是4字节 ，所以ptest就是个指针，不是数组</span></span><br></pre></td></tr></table></figure>

<p><strong>数组再补充</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> test[<span class="number">2</span>][<span class="number">5</span>]</span><br><span class="line">&#123;</span><br><span class="line">	&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>,<span class="number">1005</span>&#125;,</span><br><span class="line">	&#123;<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2003</span>,<span class="number">2004</span>,<span class="number">2005</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; test[<span class="number">0</span>] &lt;&lt; std::endl; <span class="comment">//这是个地址</span></span><br><span class="line"><span class="comment">//a + [] * int</span></span><br></pre></td></tr></table></figure>

<p><strong>C语言内存分配</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(x * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span>* pa = (<span class="type">int</span>*)<span class="built_in">calloc</span>(x, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">p = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, <span class="number">8</span>);  <span class="comment">//重新分配了大小,原来输入的值还在</span></span><br><span class="line"><span class="comment">//原来分配了100，后面更改为50，那内存地址不会变</span></span><br><span class="line"><span class="comment">//原来分配了100，后面改成200，内存地址会变，但是会把原来的内存的内容拷贝到新的内存中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">free</span>(pa);</span><br><span class="line"></span><br><span class="line"><span class="comment">//p 和 pa的值成了悬挂指针，</span></span><br><span class="line"><span class="comment">//所以free之后改成p = 0, pa = 0;</span></span><br></pre></td></tr></table></figure>

<p><strong>C++内存分配</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据类型* 指针变量名称 = new 数据类型;</span></span><br><span class="line"><span class="type">int</span>* pa = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">//数据类型* 指针变量名称 = new 数据类型[数量];</span></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line">p = <span class="keyword">new</span> <span class="type">int</span>[x];</span><br><span class="line">*p = <span class="number">500</span>;</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种释放内存的方式，不要混用</span></span><br><span class="line"><span class="keyword">delete</span> pa;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="comment">//内存复制</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>,<span class="number">1005</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(p,a,<span class="number">5</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置内存</span></span><br><span class="line"><span class="comment">//memset 可以指定内存区域每一个字节的值都设置为val,</span></span><br><span class="line"><span class="type">int</span>* pa = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//这里就是设置成0 了</span></span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="number">100</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">meeset</span><span class="params">(<span class="type">void</span>* _dst, <span class="type">int</span> val, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="comment">// val范围是0x 00 --- 0x ff   如果设置0x1234，那么只会保存34</span></span></span><br><span class="line"><span class="function"><span class="comment">//memset可以将指定内存区域每一个字节都设置为val，_size为要设置的长度（字节）</span></span></span><br></pre></td></tr></table></figure>

<p>使用动态内存分配风险</p>
<p>如果释放内存后没有清零，很危险，使用new可能会报错</p>
<p>重复释放</p>
<p>内存碎片</p>
<p>不推荐C语言和C++释放内存的语句混用</p>
<p><strong>引用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据类型&amp; 变量名称&#123;引用对象的名称&#125;;</span></span><br><span class="line"><span class="comment">//引用类型一定要初始化，就相当于一个别名</span></span><br><span class="line"><span class="type">int</span> a&#123;<span class="number">500</span>&#125;;</span><br><span class="line"><span class="type">int</span> b&#123;<span class="number">100</span>&#125;;</span><br><span class="line"><span class="type">int</span>&amp; la&#123;a&#125;;</span><br><span class="line">la = <span class="number">500</span>; <span class="comment">// 相当于 a = 500;</span></span><br><span class="line"><span class="comment">//它们所有的地址都是一样的</span></span><br><span class="line"><span class="comment">//引用设置之后就不能更改了</span></span><br><span class="line"></span><br><span class="line">la = b; <span class="comment">// a 的值编程了100</span></span><br></pre></td></tr></table></figure>

<p><strong>智能指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>[]&gt; intPtr&#123;std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">5</span>)&#125;;  <span class="comment">// 是有五个这种变量</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intPtrA&#123;std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>)&#125;;     <span class="comment">// 把指针初始化为5</span></span><br><span class="line"></span><br><span class="line">intPtr.<span class="built_in">reset</span>();  <span class="comment">// 将指针地址清零，然后把内存空间还给操作系统</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">a = intPtr.<span class="built_in">get</span>();  <span class="comment">// 将intPtr的内存地址赋值给a</span></span><br><span class="line"></span><br><span class="line">a = intPtr.<span class="built_in">release</span>();  <span class="comment">// 把指针设置为0，但还会范围占用内存的地址</span></span><br></pre></td></tr></table></figure>

<p><strong>智能指针的转移</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>[]&gt; intPtr&#123;std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">5</span>)&#125;; </span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>[]&gt; intPtrA&#123;&#125;;  </span><br><span class="line"></span><br><span class="line">intPtrA = std::<span class="built_in">move</span>(intPtr);  <span class="comment">// intPtr被清零了，失效了，intPtrA指向原来intPtr指向的位置</span></span><br></pre></td></tr></table></figure>

<p><strong>共享智能指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* a&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法</span></span><br><span class="line">std::shared_ptr&lt;类型&gt; 变量名称&#123;&#125;;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptrA&#123;&#125;; <span class="comment">// 设置为空</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptrB&#123;std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>)&#125;; <span class="comment">//将这个指针初始化为5</span></span><br><span class="line"><span class="comment">//std::make_shared不支持数组</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>[]&gt; ptrC&#123;<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">std::cout &lt;&lt; ptrA &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ptrC[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *ptrB;</span><br><span class="line"><span class="comment">/*----------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//如何共享</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptrA&#123;std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>)&#125;;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptrB&#123;ptrA&#125;;</span><br><span class="line"><span class="comment">//两个指针可以指向同一个地方</span></span><br><span class="line">std::cout &lt;&lt; ptrB &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *ptrB &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; ptrA &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *ptrA;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设有  A  B C  三个指针指向这块区域，只有当所有的指针都释放了，才会释放内存空间</span></span><br><span class="line"><span class="comment">// 会有一个计数器，来记录有几个指针指向这块区域</span></span><br><span class="line"><span class="type">long</span> std::shared_ptr.<span class="built_in">use_count</span>(); <span class="comment">// .use_count() 会返回当前指针共有多少个对象调用</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ptrA.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会将当前共享指针设置为空，同时如果当前智能指针是最后一个拥有该指针的对象，那么将释放内存。</span></span><br><span class="line">std::shared_ptr.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">ptrB.<span class="built_in">reset</span>();</span><br><span class="line">std::cout &lt;&lt; ptrB &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//*ptrB使用不了，因为被释放了</span></span><br></pre></td></tr></table></figure>

<p><img src="https://bu.dusays.com/2024/11/16/67389b688486f.png"></p>
<p><strong>指针和结构体</strong></p>
<p>通过指针访问自定义数据类型（基础部分）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> HP;</span><br><span class="line">    <span class="type">int</span> MP;</span><br><span class="line">&#125;* PRole;</span><br><span class="line"><span class="comment">// 上面不写*号相当于给Role改了个名字，写了*号就是类型指针的意思</span></span><br><span class="line"><span class="comment">//以前声明指针需要Role*    现在只需要PRole即可</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role user;</span><br><span class="line">    PRole puser = &amp;user;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  使用指针偏移来访问数据</span></span><br><span class="line">    puser-&gt;HP = <span class="number">50</span>;</span><br><span class="line">    puser-&gt;MP = <span class="number">100</span>;</span><br><span class="line">    user.HP = <span class="number">50</span>;</span><br><span class="line">    user.MP = <span class="number">50</span>;</span><br><span class="line">    std::cout &lt;&lt; (*puser).HP &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; puser-&gt;HP &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内存对齐问题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> HP;</span><br><span class="line">    <span class="type">int</span> MP;</span><br><span class="line">    <span class="type">short</span> x;</span><br><span class="line">    <span class="type">short</span> x1;</span><br><span class="line">&#125;* PRole;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role user;</span><br><span class="line">    PRole puser = &amp;user;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(Role);</span><br><span class="line">    <span class="comment">// 注销掉 x1 和不注销 x1 的结果是一样的，这里涉及到内存对齐问题。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存对齐是指在内存中存储数据时，数据的起始地址按特定的规则对齐，而不是任意的内存地址。</p>
<ul>
<li>目的：提高 CPU 访问内存的效率，因为现代 CPU 通常按字节、字或更大单位（如 4 字节或 8 字节）读取内存。</li>
<li>结果：可能会在数据之间引入填充字节（padding），以满足对齐规则</li>
</ul>
<p>对齐原则</p>
<p>每个成员的地址必须是<strong>对齐系数</strong>的整数倍。</p>
<ul>
<li>对齐系数 &#x3D; <strong>成员大小</strong> 或 <strong>默认对齐数</strong>，取较小值。</li>
</ul>
<p>结构体总大小必须是<strong>结构体最大对齐系数</strong>的倍数。</p>
<p><u>指定几个字节对齐</u></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)  <span class="comment">// 指定 2 字节对齐</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;PackedExample;</span><br><span class="line"><span class="meta">#packma pack(); <span class="comment">// 恢复默认对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接输出这个结构体占据的大小</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(PackedExample): %zu\n&quot;</span>, <span class="built_in">sizeof</span>(PackedExample));</span><br></pre></td></tr></table></figure>

<p><strong>指针安全</strong></p>
<p>悬挂指针和野指针</p>
<ol>
<li><p><strong>悬挂指针</strong>: 悬挂指针产生于指针所指向的内存已被释放或者失效后，指针本身没有及时更新或清空。在该内存释放之后，任何通过这个悬挂指针的引用或操作都是不安全的，因为这块内存可能已经重新分配给了其他的数据。</p>
<p>示例：当一个指针指向动态分配（比如使用<code>malloc</code>或<code>new</code>）的内存，并且随后该内存被释放掉（使用<code>free</code>或<code>delete</code>），而没有将指针设置为<code>NULL</code>，此时这个指针就变成了悬挂指针。</p>
</li>
<li><p><strong>野指针</strong>: 野指针通常是指未初始化的指针，它没有被设置为任何有效的地址。由于它可能指向任意位置，对野指针的解引用是危险的，并且可能会导致难以预测的行为甚至程序崩溃。</p>
<p>示例：声明了一个指针变量但是没有给它赋予确定的初始值，然后就开始使用这个指针。</p>
</li>
</ol>
<p>尽管两者看似相似，但是产生原因和解决方式有所不同：</p>
<ul>
<li><strong>悬挂指针问题</strong>可以通过确保指针在释放关联的内存资源后立即被设为<code>NULL</code>来避免。</li>
<li><strong>野指针问题</strong>则需要确保每个指针变量在使用前都被明确初始化为一个合法的地址或<code>NULL</code>。</li>
</ul>
<p>处理这两种类型的指针时，编程中的最佳实践是始终确保你的指针在声明后得到适当的初始化，在资源被释放之后更新状态，并且在解引用之前检查其有效性。</p>
<p>指针存在的俩问题：</p>
<p>1️⃣ 指针没有了，内存空间还在</p>
<p>2️⃣ 内存空间释放了，指针还有</p>
<p>野指针（悬挂指针）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 野指针</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">        p = a;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">555</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; p[<span class="number">2</span>]; <span class="comment">// 内存空间还在，没有释放</span></span><br><span class="line">    <span class="comment">// 这就是野指针  （悬挂指针）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改正方法：使用 智能指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>[]&gt; a&#123; std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">50</span>) &#125;;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">250</span>;</span><br><span class="line">    p = a.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; p[<span class="number">2</span>];  <span class="comment">// 输出250</span></span><br><span class="line">&#125; <span class="comment">// 括号结束后，内存空间会释放掉</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; p[<span class="number">2</span>]; <span class="comment">// 输出-572662307,  说明内存空间被释放了</span></span><br></pre></td></tr></table></figure>

<p>另外一种情况，存在栈里面，括号  之后栈空间没有被回收（如果分配到函数里面，那么就不会出现这种问题）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    p = a;</span><br><span class="line">    std::cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure>

<p>内存空间释放了，但是指针还在</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">    p = a;</span><br><span class="line">    std::cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; p[<span class="number">0</span>];   <span class="comment">// p指针还在</span></span><br></pre></td></tr></table></figure>

<p>补充知识：.get()函数</p>
<p>1️⃣std::shared_ptr<code>和</code>std::unique_ptr    在智能指针中，.get() 用于获取所管理的原始指针。返回指正指针内部所管理的原始指针，但不会更改其所有权或者生命周期管理。</p>
<p>2️⃣在输入流(std::istream)中，.get()用于从输入流中读取字符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::istringstream <span class="title">input</span><span class="params">(<span class="string">&quot;HEllo World&quot;</span>)</span></span>;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> (input.<span class="built_in">get</span>(c))  std::cout &lt;&lt; c;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆和栈</strong></p>
<p>堆的本质就是空闲内存，C++中把堆称为自由存储区，只要是你的程序加载后，没有占用空闲的内存，都是自由存储区，我们用new或者malloc申请的一块新内存区域，都是操作系统从堆上操作的。</p>
<p>栈是程序编译时就已经确定大小的一段内存区域，主要是用于临时变量的存储，栈的效率高于堆，但是容量有限.</p>
<p><strong>汇编知识（补充）</strong></p>
<p>在汇编语言中，<code>LEA</code>（Load Effective Address）指令用于将一个内存地址加载到寄存器中，而不是直接访问该内存地址的值。简单来说，<code>LEA</code> 计算内存地址的有效值，并将其存入目标寄存器，而不是从该内存地址加载数据。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus03函数</title>
    <url>/2024/12/11/Cplusplus03%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>函数参数：指针参数</strong></p>
<ul>
<li>如果需要传递大型数据结构，可以传递指针而不是整个数据结构，避免复制数据。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>* x, <span class="type">int</span>* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*x) *= <span class="number">100</span>;</span><br><span class="line">    (*y) *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> (*x) + (*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">Add</span>(&amp;x, &amp;y);</span><br><span class="line">    <span class="comment">//x 和  y 的值都改了  指针改的是内存中的数值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Hp;</span><br><span class="line">    <span class="type">int</span> Mp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int Exp(Role r1)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return r1.Hp + r1.Mp;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Exp</span><span class="params">(Role* r1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r1-&gt;Hp + r1-&gt;Mp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role r1&#123;<span class="number">500</span>,<span class="number">200</span>&#125;;</span><br><span class="line">    <span class="comment">//c = Exp(r1);</span></span><br><span class="line">    c = <span class="built_in">Exp</span>(&amp;r1);  <span class="comment">// 效率大大提升</span></span><br><span class="line">    std::cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>避免修随意修改值，使用常量指针限定只读操作</p>
<p>游戏小程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Hp;</span><br><span class="line">    <span class="type">int</span> Mp;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role* Acter, Role* beActer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    beActer-&gt;Hp -= Acter-&gt;damage;</span><br><span class="line">    <span class="keyword">return</span> beActer-&gt;Hp &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role User&#123; <span class="number">1000</span>,<span class="number">1500</span>,<span class="number">2222220</span> &#125;;</span><br><span class="line">    Role Monster&#123; <span class="number">1500</span>,<span class="number">100</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Act</span>(&amp;Monster, &amp;User))</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;角色死亡！！&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Act</span>(&amp;User, &amp;Monster)) std::cout &lt;&lt; <span class="string">&quot;怪物死亡！获得屠龙宝刀！&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组参数</strong></p>
<p>数组参数两种方式(等价，汇编代码也一样)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> ary[], <span class="type">unsigned</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i ++ )</span><br><span class="line">        std::cout &lt;&lt; ary[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span>* ary. <span class="type">unsigned</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i ++ )</span><br><span class="line">        std::cout &lt;&lt; ary[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面这俩都不能给到预期的结果</span></span><br><span class="line"><span class="comment">// 指针，能得到地址，但是得不到总大小，后面还得传入个数组大小才行  加个unsigned </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> ary[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(ary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> ary[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(ary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 必须指定后面的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> ary[][<span class="number">2</span>] <span class="type">unsigned</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">Sort</span>(a,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作业，改造Sort函数</p>
<p><strong>引用参数</strong></p>
<p>可以像指针一样，设定只能读不能写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role&amp; Acter, Role&amp; beAct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    beAct.hp -= Acter.damage;</span><br><span class="line">    <span class="keyword">return</span> beAct.hp &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role user&#123;<span class="number">200</span>,<span class="number">300</span>,<span class="number">850</span>&#125;;</span><br><span class="line">    Role monster&#123;<span class="number">800</span>,<span class="number">300</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Act</span>(user,monster)) std::cout &lt;&lt; <span class="string">&quot;怪物死亡，获得。。。。&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针和引用的区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(Role&amp; Acter, Role&amp; beAct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(Role* Acter, Role* beAct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Act</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 区别：指针可以传入nullptr空指针, 而引用不可以。</span></span><br></pre></td></tr></table></figure>

<p>*&amp;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Role类型的指针的引用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role&amp; Acter, Role* beAct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    beAct-&gt;hp -= Acter.damage;</span><br><span class="line">    <span class="type">bool</span> bEnd = beAct-&gt;hp&lt;<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让beAct指向Acter</span></span><br><span class="line">    beAct = (Role*)&amp;Acter;</span><br><span class="line">    <span class="keyword">return</span> beAct-&gt;hp &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role user&#123;<span class="string">&quot;奥特曼&quot;</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">500</span>&#125;;</span><br><span class="line">    Role monster&#123;<span class="string">&quot;小怪兽&quot;</span>,<span class="number">800</span>,<span class="number">300</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    Role* pRole = &amp;monster;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出的name还是小怪兽，因为在函数作用内beAct指向了Acter,但是pRole没有指向Acter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Act</span>(user, pRole)) std::cout &lt;&lt; pRole-&gt;Name &lt;&lt; <span class="string">&quot;怪物死亡。。。&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role&amp; Acter, Role*&amp; beAct)</span></span>;</span><br><span class="line"><span class="comment">// 这样 pRole也指向Acter了</span></span><br></pre></td></tr></table></figure>

<p>完整的代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">0x20</span>];</span><br><span class="line">    <span class="type">int</span> Hp;</span><br><span class="line">    <span class="type">int</span> Mp;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">&#125;*PROLE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role* Acter, PROLE&amp; beActer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    beAct-&gt;hp -= Acter-&gt;damage;</span><br><span class="line">    <span class="type">bool</span> bEnd = beAct-&gt;hp&lt;<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    beAct = (Role*)&amp;Acter;</span><br><span class="line">    <span class="keyword">return</span> beAct-&gt;hp &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role user&#123;<span class="string">&quot;奥特曼&quot;</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">500</span>&#125;;</span><br><span class="line">    Role monster&#123;<span class="string">&quot;小怪兽&quot;</span>,<span class="number">800</span>,<span class="number">300</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    PROLE pRole = &amp;monster;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Act</span>(user, pRole)) std::cout &lt;&lt; pRole-&gt;Name &lt;&lt; <span class="string">&quot;怪物死亡。。。&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>按值传递 vs 按引用传递</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role* Acter, PROLE beActer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// beActer 是 PROLE 的拷贝，修改它不会影响原始的 PROLE</span></span><br><span class="line">    beActer = (Role*)&amp;Acter;</span><br><span class="line">    <span class="keyword">return</span> beActer-&gt;Hp &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这种情况下，beActer 是 PROLE 的拷贝，修改 beActer 后不会影响 pRole。pRole 依然指向原始的 monster。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(<span class="type">const</span> Role* Acter, PROLE&amp; beActer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// beActer 是 PROLE 的引用，修改它会影响原始的 PROLE</span></span><br><span class="line">    beActer = (Role*)&amp;Acter;</span><br><span class="line">    <span class="keyword">return</span> beActer-&gt;Hp &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>* x, <span class="type">int</span>* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*x) *= <span class="number">100</span>;  <span class="comment">// 修改 x 指向的值</span></span><br><span class="line">    (*y) *= <span class="number">10</span>;   <span class="comment">// 修改 y 指向的值</span></span><br><span class="line">    <span class="keyword">return</span> (*x) + (*y);  <span class="comment">// 返回修改后的值之和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子也是值传递，但因为通过指针解引用(*x 和 *y)修改了指针所指向的变量的值，所以下面的代码实际上是修改了原始变量的内容。所以，尽管是值传递，但是通过指针传递数据导致的效果是修改了原始数据。</p>
<ul>
<li><strong>指针本身是值传递</strong>（函数内的指针 <code>x</code> 和 <code>y</code> 是原始指针的副本）。</li>
<li><strong>指针所指向的内容是通过解引用修改的</strong>（因此修改了原始数据）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = ary[i];</span><br><span class="line">    ary[i] = ary[i - <span class="number">1</span>];</span><br><span class="line">    ary[i - <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> ary[], <span class="type">unsigned</span> count, <span class="type">bool</span> BigSort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> bcase = BigSort?ary[i] &gt; ary[i - <span class="number">1</span>] : ary[i] &lt; ary[i - <span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (bcase) <span class="built_in">swap</span>(ary[i], ary[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>默认实参</strong></p>
<p>用户不指定值的时候，就使用默认的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> ary[], <span class="type">unsigned</span> count, <span class="type">bool</span> BigSort = <span class="literal">true</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>默认参数只能放在最后</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">200</span>)</span></span>; <span class="comment">// 正确， 相当于Add(100,200);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a = <span class="number">100</span>, <span class="type">int</span> b)</span></span>;  <span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">100</span>, <span class="type">int</span> c = <span class="number">250</span>)</span></span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>&amp; b = <span class="number">100</span>)</span></span>;   <span class="comment">//error   引用的本质是一个指针，指定100错了</span></span><br></pre></td></tr></table></figure>

<p><strong>不定量参数</strong></p>
<p>main: 处理命令行选项 ，有时候需要给main传递实参，一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。假定main函数位于可执行文件prog之内，向程序传递下面的选项</p>
<p><code>prog -d -o ofile data0</code></p>
<p>这些命令行通过两个可选的形参传递给main函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, cahr* argv[])</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>第二个形参是一个数组，它的元素是指向C风格字符串的指针：第一个形参argc表示数组中字符串的数量。因为第二个形参是数组，所以main函数也可以定义成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>其中 argv 指向char* 。。</p>
<p>当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素一次传递命令行提供的实参。最后一个指针之后的元素保证为0 。</p>
<p><code>argv[0] = &quot;prog&quot;;</code></p>
<p><code>argv[1] = &quot;-d&quot;;</code></p>
<p><code>argv[2] = &quot;-o&quot;;</code></p>
<p><code>argv[3] = &quot;ofile&quot;;</code></p>
<p><code>argv[4] = &quot;data0&quot;;</code></p>
<p><code>argv[5] = 0;</code></p>
<p>例题：输出程序名字和路径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// argv[0] 是程序完整的路径（包括文件名）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序名字&quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* programName = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">    <span class="comment">// strrchr 是一个 字符串函数，用于查找路径中最后一次出现反斜杠\位置。</span></span><br><span class="line">    <span class="comment">// 如果找到反斜杠，返回指向它的指针   否则返回nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (programName != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        programName++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;程序名称：&quot;</span> &lt;&lt; programName &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;程序名称：&quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用刚学的find方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">0</span>) std::string programPath = argv[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序路径：&quot;</span> &lt;&lt; programPath &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::<span class="type">size_t</span> lastSlash = programPath.<span class="built_in">rfind</span>(<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (lastSlash == std::string::npos) lastSlash = programPath.<span class="built_in">rfind</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lastSlash != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string programName = programPath.<span class="built_in">substr</span>(lastSlash + <span class="number">1</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;程序名称： &quot;</span> &lt;&lt; programName &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;程序名称： &quot;</span> &lt;&lt; programPath &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可变形参的函数</strong></p>
<p>使用 <code>...</code> 语法（C 风格的可变参数）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span>  <span class="comment">// 头文件支持可变参数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="comment">// 可以使用char* args&#123;&#125;; 替代</span></span><br><span class="line">    <span class="comment">// 告诉args有多少个参数</span></span><br><span class="line">    <span class="built_in">va_start</span>(args, count);  <span class="comment">// 初始化 args 以访问可变参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印传入的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="comment">// 要读的指针  和  参数的类型</span></span><br><span class="line">        <span class="comment">// 每调用一次，就能获取下一个参数</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">va_arg</span>(args, <span class="type">int</span>);  <span class="comment">// 获取下一个参数，类型为 int</span></span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(args);  <span class="comment">// 清理  释放args</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printNumbers</span>(<span class="number">3</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);  <span class="comment">// 打印 10 20 30</span></span><br><span class="line">    <span class="built_in">printNumbers</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  <span class="comment">// 打印 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>std::initializer_list</code>(C++11之后)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNumbers</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printNumbers</span>(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;);  <span class="comment">// 打印 10 20 30</span></span><br><span class="line">    <span class="built_in">printNumbers</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);  <span class="comment">// 打印 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>std::vector</code> 或者其他容器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNumbers</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printNumbers</span>(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;);  <span class="comment">// 打印 10 20 30</span></span><br><span class="line">    <span class="built_in">printNumbers</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);  <span class="comment">// 打印 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>std::function</code>  和 Lambda 表达式（高级用法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">applyFunction</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Lambda 接受不定数量参数</span></span><br><span class="line">    <span class="built_in">applyFunction</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda with no arguments!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一个小作业</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">ReadRef</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ref, <span class="type">const</span> <span class="type">char</span>* cmds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; cmds[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmds[i] == ref[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> found = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span>  x;</span><br><span class="line">            <span class="keyword">for</span> (x = <span class="number">0</span>; ref[x]; x ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ref[x] != cmds[i + x])</span><br><span class="line">                &#123;</span><br><span class="line">                    found = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">return</span> &amp;cmds[i + x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* id = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pass = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* country = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!id) id = <span class="built_in">ReadRef</span>(<span class="string">&quot;id:&quot;</span>, argv[i]);</span><br><span class="line">        <span class="keyword">if</span> (!pass) pass = <span class="built_in">ReadRef</span>(<span class="string">&quot;pass:&quot;</span>, argv[i]);</span><br><span class="line">        <span class="keyword">if</span> (!country) country = <span class="built_in">ReadRef</span>(<span class="string">&quot;country:&quot;</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (id &amp;&amp; pass &amp;&amp; country) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;注册成功！\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;账号：&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;密码：&quot;</span> &lt;&lt; pass &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;国家：&quot;</span> &lt;&lt; country &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;参数不足！请按以下格式调用程序：\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;./program id:&lt;your_id&gt; pass:&lt;your_pass&gt; country:&lt;your_country&gt;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus02联合体和字符串</title>
    <url>/2024/12/11/Cplusplus02%E8%81%94%E5%90%88%E4%BD%93%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><strong>联合体语法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示范</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">USER</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="type">short</span> sHP;</span><br><span class="line">    <span class="type">int</span> nHP;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 通过union 可以创建一个联合体，union中的成员变量共享内存，因此union的数据类型大小由其最大的成员变量决定。</span></span><br></pre></td></tr></table></figure>

<p>实践一下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 联合体</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">USER</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> sHP;</span><br><span class="line">	<span class="type">int</span> nHP;</span><br><span class="line">	<span class="type">double</span> fHP;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="type">short</span> sHP;</span><br><span class="line">	<span class="type">int</span> nHP;</span><br><span class="line">	<span class="type">double</span> fHP;</span><br><span class="line">&#125; ls;<span class="comment">// 不重用，临时的 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="type">short</span> sHP;</span><br><span class="line">	<span class="type">int</span> nHP;</span><br><span class="line">	<span class="type">double</span> fHP;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 内存分配   没有初始化</span></span><br><span class="line">	USER user;</span><br><span class="line">	Test t;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">sizeof</span>(user) &lt;&lt; std::endl; </span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">sizeof</span>(t) &lt;&lt; std::endl;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	user.sHP = <span class="number">100</span>;<span class="comment">//[100][0][][][][][][]</span></span><br><span class="line">	std::cout &lt;&lt; user.sHP &lt;&lt; std::endl;  <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//[100][0][？][？][？][？][？][？]</span></span><br><span class="line">	<span class="comment">// 访问4个格子，但有俩没有初始化，不知道是什么值</span></span><br><span class="line">	std::cout &lt;&lt; user.nHP &lt;&lt; std::endl;  </span><br><span class="line">	user.nHP = <span class="number">0</span>;</span><br><span class="line">	std::cout &lt;&lt; user.nHP &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未命名的联合体是供临时使用的！</p>
<p><strong>C 语言中 字符串的拼接</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">0x10</span>] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">char</span> strB[<span class="number">0x10</span>] = <span class="string">&quot;456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> strC[<span class="number">0x20</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(strC, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"><span class="built_in">memcpy</span>(strC + <span class="built_in">strlen</span>(str), strB, <span class="built_in">strlen</span>(strB) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strC;</span><br></pre></td></tr></table></figure>

<p><strong>C++ 中 字符串拼接</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str&#123;<span class="string">&quot;12345&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 不必考虑溢出</span></span><br><span class="line">std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">string str1&#123; <span class="string">&quot;123455&quot;</span>, <span class="number">3</span> &#125;; <span class="comment">// 只要前面三个字符串</span></span><br><span class="line">std::cout &lt;&lt; str1 &lt;&lt; std::endl;  <span class="comment">// 输出123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string str2&#123; <span class="string">&quot;0123456&quot;</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;  <span class="comment">// 从2开始截取3位</span></span><br><span class="line">std::cout &lt;&lt; str2 &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 对中文支持的不太好</span></span><br><span class="line">string str3&#123; <span class="string">&quot;你好啊啊啊&quot;</span>, <span class="number">3</span> &#125;;</span><br><span class="line">std::cout &lt;&lt; str3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">str4</span><span class="params">(<span class="number">6</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;  <span class="comment">// 6个  a</span></span><br><span class="line"><span class="function">string <span class="title">str5</span><span class="params">(<span class="number">6</span>, <span class="number">65</span>)</span></span>;  <span class="comment">//转成大写的A</span></span><br><span class="line">std::cout &lt;&lt; str4 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; str5 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接字符串</span></span><br><span class="line">string str6, str7;</span><br><span class="line">str6 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">str7 = <span class="string">&quot;456&quot;</span>;</span><br><span class="line"></span><br><span class="line">str6 = str7 + <span class="string">&quot; &quot;</span> + <span class="string">&quot;123&quot;</span>;  <span class="comment">// 这里一定要有string 类型的变量在这里</span></span><br><span class="line">std::cout &lt;&lt; str6 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把数字转换成字符串</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">std::cin &gt;&gt; age;</span><br><span class="line"></span><br><span class="line">string st;</span><br><span class="line">st = <span class="string">&quot; 用户的年龄是：&quot;</span>;</span><br><span class="line">str7 = st + std::<span class="built_in">to_string</span>(age);</span><br><span class="line">std::cout &lt;&lt; str7;</span><br></pre></td></tr></table></figure>

<p><strong>C++ 中字符串拼接（进阶）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SoftName <span class="string">&quot;EDY&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SoftVersion <span class="string">&quot;2.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//str = &quot;1233&quot; + &quot;1222&quot;;</span></span><br><span class="line">	<span class="comment">// 不能直接连接两个字符串</span></span><br><span class="line">	str = string&#123; <span class="string">&quot;!22&quot;</span> &#125; + <span class="string">&quot;1233&quot;</span>;  <span class="comment">// 把字符串放到临时变量里面就可以了</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">//str = &quot;1233&quot; + &quot;bcbc&quot; + string&#123; &quot;!22&quot; &#125;;   error</span></span><br><span class="line">	<span class="comment">// 前面两个加法是直接的字符串的字面量</span></span><br><span class="line">	<span class="comment">//改进</span></span><br><span class="line">	str = <span class="string">&quot;abc&quot;</span> + (<span class="string">&quot;bcd&quot;</span> + string&#123; <span class="string">&quot;123&quot;</span> &#125;); <span class="comment">// 这样就可以了</span></span><br><span class="line"></span><br><span class="line">	str += <span class="string">&quot;aka&quot;</span>;  <span class="comment">// 没问题</span></span><br><span class="line">	<span class="comment">//str += &quot;aka&quot; + &quot;bka&quot;;    +的优先级大于   +=</span></span><br><span class="line">	<span class="comment">// 解决办法如下</span></span><br><span class="line">	str += <span class="string">&quot;aka&quot;</span> + string&#123; <span class="string">&quot;bka&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	string strB;</span><br><span class="line">	<span class="comment">// 连接</span></span><br><span class="line">	strB = <span class="string">&quot;!23&quot;</span><span class="string">&quot;233&quot;</span>;</span><br><span class="line">	<span class="comment">// 唯一用途</span></span><br><span class="line">	strB = SoftName SoftVersion;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串连接  字符</span></span><br><span class="line">    string strC&#123;<span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    std::cin &gt;&gt; a;</span><br><span class="line">    str += a;  <span class="comment">// 允许这样连接</span></span><br><span class="line">    <span class="comment">// 注意事项</span></span><br><span class="line">    str += a + <span class="string">&#x27;o&#x27;</span>;  <span class="comment">// 两个字符  是俩常量，可以相加    字符a 与 字符o相加之后再连接</span></span><br><span class="line">    <span class="comment">// 相当于</span></span><br><span class="line">    str += <span class="built_in">char</span>(a + <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="comment">// 字符串不能相加的原因是， 字符串是两个char类型的数组</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拼接方法</span></span><br><span class="line">    string strD&#123;<span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">    strD.<span class="built_in">append</span>(<span class="string">&quot;456&quot;</span>);  <span class="comment">// 在字符串后面拼接上456</span></span><br><span class="line">    strD.<span class="built_in">append</span>(<span class="string">&quot;222&quot;</span>).<span class="built_in">append</span>(<span class="string">&quot;dfddd&quot;</span>);  <span class="comment">// 无限  加append</span></span><br><span class="line">    <span class="comment">// 拼接的时候也可以有选择</span></span><br><span class="line">    strD.<span class="built_in">append</span>(<span class="string">&quot;123455&quot;</span>, <span class="number">2</span>); <span class="comment">// 从2开始拼接   跟字符串初始化用法一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>截取字符串</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">substr</span>(起始位置,要截取的长度);</span><br><span class="line"></span><br><span class="line">std::string str&#123;<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line">std::string strsub&#123;str.<span class="built_in">substr</span>(<span class="number">1</span>)&#125;;  <span class="comment">// strsub = &quot;23456&quot;</span></span><br><span class="line">std::string strsubA&#123;str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>)&#125;; <span class="comment">// strsubA = &quot;234&quot;;</span></span><br><span class="line"></span><br><span class="line">string strB;</span><br><span class="line"><span class="comment">// 也可以连着截取，但是要放到一个新的string里面</span></span><br><span class="line">strB = str.<span class="built_in">substr</span>(<span class="number">7</span>).<span class="built_in">substr</span>(<span class="number">3</span>);  <span class="comment">// 提取从索引7开始的子字符串（包括索引 7 的字符）， 直到字符串末尾。.substr(3) 在上一步的基础上，从索引 3 开始提取子字符串 （包括索引3 的字符）， 直到字符串末尾。</span></span><br><span class="line"><span class="comment">// 字符串的索引也是从0开始的</span></span><br><span class="line"><span class="comment">// substr不会改变str的值，而append会改变</span></span><br></pre></td></tr></table></figure>

<p><strong>计算字符串长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str&#123;<span class="string">&quot;222222&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 对中文字符串长度的计算还是不准确</span></span><br><span class="line">std::cout &lt;&lt; str.<span class="built_in">length</span>();</span><br></pre></td></tr></table></figure>

<p>下面是一个正常计算字符串的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置区域为中文   确保宽字符输入/输出流能正确处理中文字符。</span></span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;chs&quot;</span>);</span><br><span class="line">    <span class="type">wchar_t</span> wstr[<span class="number">255</span>]; <span class="comment">// 定义宽字符数组</span></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;请输入一个字符串: &quot;</span>;</span><br><span class="line">    std::wcin.<span class="built_in">getline</span>(wstr, <span class="number">255</span>); <span class="comment">// 使用宽字符输入</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; wstr[i] != <span class="string">L&#x27;\0&#x27;</span>; ++i) &#123; <span class="comment">// 遍历宽字符数组</span></span><br><span class="line">        ++length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;字符串的长度是: &quot;</span> &lt;&lt; length &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字符串比较</strong></p>
<p>1️⃣ 比较相同的内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* str_1&#123;(<span class="type">char</span>*)<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span>* str_2&#123;(<span class="type">char</span>*)<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; (str1 == str2) &lt;&lt; std::endl;  <span class="comment">// 地址相等，进行优化之后指向相同的位置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* str_1&#123;(<span class="type">char</span>*)<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span>* str_2 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">7</span>];</span><br><span class="line">std::cin &gt;&gt; str_2;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; (str1 == str2) &lt;&lt; std::endl;  <span class="comment">// 输入123456  是不相等的</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str_1&#123;<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line">string str_2;</span><br><span class="line"></span><br><span class="line">std::cin &gt;&gt; str_2;</span><br><span class="line">std::cout &lt;&lt; (str1 == str2) &lt;&lt; std::endl;   <span class="comment">// 手动输入123456   是相等的</span></span><br></pre></td></tr></table></figure>

<p>2️⃣ 比较不同的内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str_1&#123;<span class="string">&quot;abcdef&quot;</span>&#125;;</span><br><span class="line">string str_2&#123;<span class="string">&quot;bcdefg&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第一个字符开始比较，如果比出来大小后面就不比较了</span></span><br><span class="line"><span class="keyword">if</span>(str_1 &gt; str_2)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;大于&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;小于等于&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str_1&#123;<span class="string">&quot;abcdef&quot;</span>&#125;;</span><br><span class="line">str<span class="number">1.</span><span class="built_in">compare</span>(<span class="string">&quot;bcdefg&quot;</span>); <span class="comment">// 返回一个int类型的值</span></span><br><span class="line"><span class="comment">// 如果str1比另外一个字符串小返回负数 -1， 如果相等返回 0  如果大于返回 1</span></span><br></pre></td></tr></table></figure>

<p>3️⃣ 截取一段之后进行比较</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string strA&#123;<span class="string">&quot;abc cdef&quot;</span>&#125;;</span><br><span class="line">strA.<span class="built_in">compare</span>(<span class="number">5</span>,<span class="number">4</span>,<span class="string">&quot;cdef&quot;</span>); <span class="comment">// 截取的是strA   compare(起始位置,参与比较的长度,被比较的字符串);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string strA&#123;<span class="string">&quot;abc cdef&quot;</span>&#125;;</span><br><span class="line">strA.<span class="built_in">compare</span>(<span class="number">5</span>,<span class="number">4</span>,<span class="string">&quot;cdef ghijklm&quot;</span>, <span class="number">0</span>, <span class="number">4</span>); <span class="comment">// 前面截图的strA， 后面截取的是&quot;cdef ghijklm&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string strA&#123;<span class="string">&quot;username:5620;studentId:655555&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; strA.<span class="built_in">find</span>(<span class="string">&quot;studentId:&quot;</span>); <span class="comment">// 返回字符串的起始位置</span></span><br><span class="line">std::cout &lt;&lt; strA.<span class="built_in">substr</span>(strA.<span class="built_in">find</span>(<span class="string">&quot;studentId:&quot;</span>)); <span class="comment">// 输出  studentId:655555</span></span><br><span class="line">std::cout &lt;&lt; strA.<span class="built_in">substr</span>(strA.<span class="built_in">find</span>(<span class="string">&quot;studentId:&quot;</span>) + <span class="number">10</span>); <span class="comment">//输出655555</span></span><br></pre></td></tr></table></figure>

<p>补充  find()  方法 的用法</p>
<p><img src="https://bu.dusays.com/2024/11/21/673ee8f79c446.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">str.<span class="built_in">find</span>(<span class="string">&quot;sdajklfdkasjlkfjlas&quot;</span>, <span class="number">0</span>, <span class="number">10</span>); <span class="comment">//在字符串 str 中，从位置 0 开始，查找字符串 &quot;sdajklfdkasjlkfjlas&quot; 的前 10 个字符是否存在。</span></span><br></pre></td></tr></table></figure>

<p>倒着搜索</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示从字符串 str 的 索引 0 位置向前（从右到左查找）寻找目标字符串 &quot;sdajklfdkasjlkfjlas&quot;</span></span><br><span class="line">str.<span class="built_in">rfind</span>(<span class="string">&quot;sdajklfdkasjlkfjlas&quot;</span>, <span class="number">0</span>); </span><br></pre></td></tr></table></figure>



<p><strong>字符串的应用–小项目</strong></p>
<p><img src="https://bu.dusays.com/2024/11/21/673ef4d76891d.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str&#123; <span class="string">&quot;id=user;pas=632105;role=阿森;&quot;</span> &#125;;</span><br><span class="line">	string strIn;</span><br><span class="line">	string strOut;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;请输入您要查阅的属性：\n&quot;</span>;</span><br><span class="line">		std::cin &gt;&gt; strIn;</span><br><span class="line">		<span class="type">int</span> lfind = str.<span class="built_in">find</span>(strIn + <span class="string">&quot;=&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (lfind == std::string::npos)</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;查找的属性不存在&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> lend = str.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>, lfind);</span><br><span class="line">			strOut = str.<span class="built_in">substr</span>(lfind + strIn.<span class="built_in">length</span>() + <span class="number">1</span>, lend - lfind - strIn.<span class="built_in">length</span>() - <span class="number">1</span>);</span><br><span class="line">			std::cout &lt;&lt; strOut &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入字符串</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">.<span class="built_in">insert</span>();</span><br><span class="line">string id&#123;<span class="string">&quot;id=;&quot;</span>&#125;;</span><br><span class="line">id.<span class="built_in">insert</span>(<span class="number">3</span>,<span class="string">&quot;testId&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; id;</span><br></pre></td></tr></table></figure>

<p><img src="https://bu.dusays.com/2024/11/21/673f1c5e64bea.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">string id&#123;<span class="string">&quot;id=&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 从索引插入6个*</span></span><br><span class="line">id.<span class="built_in">insert</span>(<span class="number">3</span>,<span class="number">6</span>,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">id.<span class="built_in">insert</span>(<span class="number">3</span>, <span class="string">&quot;testid&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; id;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string id&#123;<span class="string">&quot;id=&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 3 是从id字符串索引3开始插入，后面的第一个6是从字符串&quot;killertestid&quot;索引6开始插入6个字符到字符串id中</span></span><br><span class="line">id.<span class="built_in">insert</span>(<span class="number">3</span>,<span class="string">&quot;killertestid&quot;</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string id&#123;<span class="string">&quot;id=&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 在id字符串索引3开始插入 ，  然后从字符串&quot;killertestid123456&quot;的k开始插入6个</span></span><br><span class="line">id.<span class="built_in">insert</span>(<span class="number">3</span>,<span class="string">&quot;killertestid123456&quot;</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p><strong>指针数组字符串</strong></p>
<p>str和 str[0] 不是一个位置，具体跟数组有区别，涉及到运算符重载</p>
<p>str的地址和str[0]的地址差4</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str&#123;<span class="string">&quot;12344&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 不转int会当作字符串来输出</span></span><br><span class="line">std::cout &lt;&lt; (<span class="type">int</span>)&amp;str &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str&#123;<span class="string">&quot;12345&quot;</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; str[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; (<span class="type">int</span>)&amp;str &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">str = str + <span class="string">&quot;534894539823478923&quot;</span>;</span><br><span class="line"><span class="comment">// str  跟 str[0]地址相差就很多了，需要重新分配内存地址</span></span><br><span class="line">std::cout &lt;&lt; (<span class="type">int</span>)&amp;str &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .c_str() 返回的是 const char*，不能直接通过指针修改字符串内容。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* baseStr = str.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="comment">// baseStr[0] = &#x27;5&#x27;;   不允许修改</span></span><br><span class="line">std::cout &lt;&lt; (<span class="type">int</span>)&amp;str &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)baseStr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 17 之后 .data()方法得到的是一个char* 的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* dataStr = str.<span class="built_in">data</span>();</span><br><span class="line"><span class="comment">// dataStr[0] = &#x27;5&#x27;;   不允许修改</span></span><br><span class="line">std::cout &lt;&lt; (<span class="type">int</span>)&amp;str &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;str[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">int</span>)baseStr &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>



<ul>
<li>返回一个 <code>const char*</code> 指针，指向以空字符 <code>\0</code> 结尾的 C 风格字符串。</li>
<li>返回的字符串数据与 <code>std::string</code> 对象内部保持一致，但不能修改返回值（它是 <code>const</code> 的）。</li>
</ul>
<p><strong>字符串替换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法1</span></span><br><span class="line">.<span class="built_in">replace</span>(要替换的内容的起始位置，要替换的长度，“替换后的内容”);</span><br><span class="line"></span><br><span class="line">string strId&#123;<span class="string">&quot;id=user;&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 替换从索引 3 开始的 4 个字符为 &quot;zhangsan&quot;</span></span><br><span class="line">strId.replace&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;zhangsan&quot;</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; strId;  <span class="comment">// id=zhangsan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法2</span></span><br><span class="line">.<span class="built_in">replace</span>(要替换的内容的起始位置，要替换的长度，替换后的字符长度，‘字符’);</span><br><span class="line"><span class="comment">// 替换从索引 3 开始的 4 个字符，用 6 个 &#x27;*&#x27; 替换</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"><span class="comment">// str的内容为：id=******</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法3</span></span><br><span class="line">.<span class="built_in">replace</span>(要替换的内容的起始位置，要替换的长度，<span class="string">&quot;替换后的内容&quot;</span>，替换后内容的长度节选);</span><br><span class="line"><span class="comment">// 替换从索引 3 开始的 4 个字符，用 &quot;zhangsan!pkaq&quot; 的前 8 个字符替换</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;zhangsan!pkaq&quot;</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法4</span></span><br><span class="line">.<span class="built_in">replace</span>(要替换的内容的起始位置，要替换的长度，<span class="string">&quot;替换后的内容&quot;</span>，替换后的内容的起始位置，替换后内容的长度节选);</span><br><span class="line"><span class="comment">// 替换从索引 3 开始的 4 个字符，用 &quot;zhangsan!pkaq&quot; 的从第9个字符开始截取，截取4个</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;zhangsan!pkaq&quot;</span>,<span class="number">9</span>，,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p><strong>删除字符串内容</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法1</span></span><br><span class="line">.<span class="built_in">erase</span>(要删除的起始位置,要删除的起始长度);</span><br><span class="line"></span><br><span class="line">string str&#123;<span class="string">&quot;id=user;&quot;</span>&#125;;</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">// id=;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法2</span></span><br><span class="line">.<span class="built_in">erase</span>(要删除的起始位置); <span class="comment">// 从起始位置开始删除所有内容</span></span><br><span class="line">string str&#123;<span class="string">&quot;id=user;&quot;</span>&#125;;</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// id = </span></span><br><span class="line"></span><br><span class="line">.<span class="built_in">erase</span>();   <span class="comment">//删除字符串所有内容   擦除</span></span><br><span class="line">.<span class="built_in">clear</span>();   <span class="comment">//删除字符串所有内容   清零</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串（补充）</strong></p>
<p>计算字符串长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string strIn;</span><br><span class="line">std::cin &gt;&gt; strIn;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> length&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; strIn[i]; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在 ASCII 编码中，单字节字符（如英文、数字）均为非负数（0-127）</span></span><br><span class="line">    <span class="keyword">if</span> (strIn[i] &lt; <span class="number">0</span>) i ++ ;</span><br><span class="line">    length ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样就能统计出字符个数了</span></span><br><span class="line">std::cout &lt;&lt; length;</span><br></pre></td></tr></table></figure>

<p>字符串转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string cIn = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> x = std::<span class="built_in">stoi</span>(cIn); <span class="comment">// 转换成int类型</span></span><br></pre></td></tr></table></figure>

<p><img src="https://bu.dusays.com/2024/11/21/673f31c813942.png"></p>
<p>字符串流</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::stringstream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream strS;</span><br><span class="line">    <span class="comment">// 这是按照16进制来输出的</span></span><br><span class="line">    strS &lt;&lt; <span class="string">&quot;你好&quot;</span> &lt;&lt; <span class="string">&quot;123 [&quot;</span> &lt;&lt; std::hex &lt;&lt; <span class="number">12530</span> &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    string strX = strS.<span class="built_in">str</span>();</span><br><span class="line">    std::cout &lt;&lt; strX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字符串项目</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    string Id;</span><br><span class="line">    <span class="type">int</span> Exp;</span><br><span class="line">&#125;*PROLE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string strData = <span class="string">&quot;id=Tomy Clare;exp=9523;id=Sunny;exp=9523;id=DyBaby;exp=25301;id=Simple;exp=25301;id=Bkacs11;exp=2100;id=Dudu;exp=2122;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> istart&#123;&#125;, iend&#123;&#125;, icount&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strData.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (strData[i] == <span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            icount++;</span><br><span class="line">            i += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PROLE pRole = <span class="keyword">new</span> Role[icount / <span class="number">2</span>];</span><br><span class="line">    icount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查找到id=   则把istart 将更新为 &quot;id=&quot; 首次出现的索引</span></span><br><span class="line">        istart = strData.<span class="built_in">find</span>(<span class="string">&quot;id=&quot;</span>, istart);</span><br><span class="line">        <span class="keyword">if</span> (istart == std::string::npos) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        iend = strData.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>, istart + <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 从istart开始截取，截取长度就是iend-istart-3</span></span><br><span class="line">        pRole[icount].Id = strData.<span class="built_in">substr</span>(istart + <span class="number">3</span>, iend - istart - <span class="number">3</span>);</span><br><span class="line">        istart = iend + <span class="number">1</span>;</span><br><span class="line">        iend = strData.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>, istart + <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 在这里 icount ++ 省去后面再++ 了</span></span><br><span class="line"></span><br><span class="line">        pRole[icount++].Exp = std::<span class="built_in">stoi</span>(strData.<span class="built_in">substr</span>(istart + <span class="number">4</span>, iend - istart - <span class="number">4</span>));</span><br><span class="line">        istart = iend + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冒泡排序  经典冒泡排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; icount - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; icount - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pRole[j].Exp &lt; pRole[j + <span class="number">1</span>].Exp ||</span><br><span class="line">                (pRole[j].Exp == pRole[j + <span class="number">1</span>].Exp &amp;&amp; pRole[j].Id &gt; pRole[j + <span class="number">1</span>].Id)) &#123;</span><br><span class="line">                Role temp = pRole[j];</span><br><span class="line">                pRole[j] = pRole[j + <span class="number">1</span>];</span><br><span class="line">                pRole[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; icount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; pRole[i].Id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pRole[i].Exp &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus04函数进阶</title>
    <url>/2024/12/11/Cplusplus04%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p><strong>函数返回-返回指针和引用</strong></p>
<p>返回指针不要返回局部变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">cstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">clen</span>(str);</span><br><span class="line">   <span class="comment">// char strRt[0x20];   // 这就是错误示范，返回了一个局部变量</span></span><br><span class="line">    <span class="comment">// 只要不释放，一直在堆上面</span></span><br><span class="line">    <span class="type">char</span>* strRt = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">    <span class="built_in">memcpy</span>(strRt, str, len);</span><br><span class="line">    <span class="keyword">return</span> strRt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目设计</p>
<p><img src="https://bu.dusays.com/2024/11/24/6742aa525f2f5.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* name;</span><br><span class="line">	<span class="type">int</span> Hp;</span><br><span class="line">	<span class="type">int</span> maxHp;</span><br><span class="line">	<span class="type">int</span> Mp;</span><br><span class="line">	<span class="type">int</span> maxMp;</span><br><span class="line">	<span class="type">int</span> lv;</span><br><span class="line">&#125;*PROLE, ROLE;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; str[i]; i++);</span><br><span class="line">	<span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">cstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 不要返回一个局部变量</span></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">clen</span>(str);</span><br><span class="line">	<span class="comment">// 只要不释放，一直在堆上面</span></span><br><span class="line">	<span class="type">char</span>* strRt = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">	<span class="built_in">memcpy</span>(strRt, str, len);</span><br><span class="line">	<span class="keyword">return</span> strRt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ROLE <span class="title">CreateMonster</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> Hp, <span class="type">int</span> Mp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请了空间，把它返回之后，还得赋值到 role上面，造成了性能损失</span></span><br><span class="line">	Role rt&#123; <span class="built_in">cstr</span>(str), Hp, Hp, Mp, Mp, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* str;</span><br><span class="line">	str = <span class="built_in">cstr</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">	std::cout &lt;&lt; str;</span><br><span class="line"></span><br><span class="line">	ROLE role = <span class="built_in">CreateMonster</span>(<span class="string">&quot;aoteman&quot;</span>, <span class="number">1500</span>, <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; role.name &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; role.Hp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------改进方法1️⃣  返回指针--------------------*/</span></span><br><span class="line"><span class="function">PROLE <span class="title">CreateMonster</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> Hp, <span class="type">int</span> Mp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这下返回的是4字节的指针</span></span><br><span class="line">	PROLE rt = <span class="keyword">new</span> ROLE&#123; <span class="built_in">cstr</span>(str), Hp, Hp, Mp, Mp, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* str;</span><br><span class="line">	str = <span class="built_in">cstr</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">	std::cout &lt;&lt; str;</span><br><span class="line"></span><br><span class="line">	PROLE role = <span class="built_in">CreateMonster</span>(<span class="string">&quot;aoteman&quot;</span>, <span class="number">1500</span>, <span class="number">1500</span>);</span><br><span class="line">    <span class="comment">// 这样的话性能折损几乎没有了</span></span><br><span class="line">	std::cout &lt;&lt; role-&gt;name &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; role-&gt;Hp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------改进方法2️⃣  返回引用--------------------*/</span></span><br><span class="line"><span class="function">ROLE&amp; <span class="title">CreateMonster</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> Hp, <span class="type">int</span> Mp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PROLE rt = <span class="keyword">new</span>&#123; <span class="built_in">cstr</span>(str), Hp, Hp, Mp, Mp, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">// 由于是引用，所以不能传空指针</span></span><br><span class="line">	<span class="keyword">return</span> *rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* str;</span><br><span class="line">	str = <span class="built_in">cstr</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">	std::cout &lt;&lt; str;</span><br><span class="line"></span><br><span class="line">	ROLE&amp; role = <span class="built_in">CreateMonster</span>(<span class="string">&quot;aoteman&quot;</span>, <span class="number">1500</span>, <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; role.name &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; role.Hp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组的引用（补充）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br><span class="line"><span class="type">int</span> c[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// int&amp; d[100] = c;  error</span></span><br><span class="line"><span class="built_in">int</span> (&amp;e)[<span class="number">100</span>] = a;  <span class="comment">// 必须为100 才行   而且得告诉编译器，e是个引用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>(&amp;art)[<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(art) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : art);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> c[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">int</span> (&amp;b)[<span class="number">100</span>] = c;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ave</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>右值引用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add1</span><span class="params">(<span class="type">int</span>&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add2</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">320</span> + <span class="number">250</span>;</span><br><span class="line">    <span class="type">int</span>&amp; d = c;</span><br><span class="line">    <span class="comment">// 右值引用 &amp;&amp;</span></span><br><span class="line">    <span class="comment">// int&amp;&amp; e = d;  右值引用你就不能指向内存中有位置的对象，</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; e = <span class="number">320</span>;   <span class="comment">// 右值引用可以指向临时的东西</span></span><br><span class="line">    </span><br><span class="line">    e = <span class="number">1500</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = c + <span class="number">100</span> + <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">Add2</span>(x);</span><br><span class="line">    <span class="comment">// 使用右值引用，减少不必要的内存浪费</span></span><br><span class="line">    <span class="built_in">Add1</span>(c + <span class="number">100</span> + <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Role <span class="title">CrateMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role rt&#123;<span class="number">100</span>,<span class="number">200</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(Role&amp;&amp; r1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; r<span class="number">1.</span>hp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Show</span>(<span class="built_in">CreateMonster</span>());</span><br><span class="line">    <span class="comment">// 原来的方法是创建一个额外的变量来保存</span></span><br><span class="line">    <span class="comment">// ROLE role = CreateMonster(&quot;aoteman&quot;, 1500, 1500);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://bu.dusays.com/2024/11/24/6742beef8067c.png"></p>
<p>右边的部分，<code>Role r1</code> 是需要创建变量的，有内存开销。  <code>Role&amp; r1</code>无法传递局部变量（临时量）。</p>
<p>左边部分，虽然Role CreateRole()分配到栈里，但跑到下一个函数，这部分内容要擦除的。</p>
<p><strong>函数的本质（底层）</strong></p>
<p><img src="https://bu.dusays.com/2024/11/24/6742c2f421215.png"> push  有个作用  传参的    ，把参数推到栈区</p>
<p><img src="https://bu.dusays.com/2024/11/24/6742c5e9d7b54.png"></p>
<p>函数的名字就是一个内存地址  代码就是二进制数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Add;  <span class="comment">//函数的名字就是一个内存地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* str = (<span class="type">char</span>*)Add;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">char</span>)str[i]);</span><br><span class="line">        <span class="comment">// 打印出来的内容就是命令对应的二进制</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试下能不能写入</span></span><br><span class="line">    <span class="comment">// str[0] = 25; 出错  常量一样，，不让写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数指针</strong></p>
<p>函数返回类型  (*函数指针变量名)(参数类型  参数名称, …  参数类型  参数名称);</p>
<p><code>int (*pAdd)(int a, int b)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新用法</span></span><br><span class="line"><span class="comment">// 声明一个函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span><span class="params">(*pfAdd)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">using</span> pFAdd = <span class="built_in">char</span> (*)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">AddX</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 类型转换  上面声明的 两个类型</span></span><br><span class="line">    pfAdd pAdd1 = (pfAdd)Add1;</span><br><span class="line">    pFAdd pAdd2 = (pFAdd)AddX;</span><br><span class="line">    <span class="comment">// 类型不一样的时候使用强制类型转换</span></span><br><span class="line">    <span class="comment">// 声明函数指针</span></span><br><span class="line">    <span class="built_in">int</span> (*pxAdd)(<span class="type">int</span>, <span class="type">int</span>) = AddX;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">pxAdd</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(pAdd1) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">pAdd1</span>(<span class="number">30</span>, <span class="number">35</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips</p>
<p><img src="https://bu.dusays.com/2024/11/24/6742d6cc78d8f.png"></p>
<p><strong>从函数的角度彻底认识栈</strong></p>
<p>栈十分重要，底层很重要</p>
<p>1️⃣ 栈是预先分配好的，连续的内存空间，局部变量就放在栈空间上，通过控制esp来实现局部变量的创建和释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">250</span>;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">Ave</span>(a, b);</span><br><span class="line">    c = c + d;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2️⃣ 栈平衡如果被破坏，函数就可能不能返回到预期的位置，同理，利用这个原理，我们也可以控制目标程序进入指定的位置，来获取目标操作系统的控制权限，这也就是栈攻击的技术原理，同时编写代码时也要积极预防栈攻击。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span>C61073 <span class="number">6</span>A <span class="number">32</span>             push   <span class="number">32</span>h</span><br><span class="line"><span class="number">00</span>C61075 <span class="number">68</span> FA <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    push   <span class="number">0</span>FAh</span><br><span class="line"><span class="number">00</span>C6107A E8 A1 FF FF FF    call   <span class="number">00</span>C61020</span><br><span class="line"><span class="number">00</span>C6107F <span class="number">83</span> C4 <span class="number">0</span>8          add    esp,<span class="number">8</span></span><br><span class="line"><span class="number">00</span>C61082 <span class="number">89</span> <span class="number">45</span> FC          mov    dword ptr [ebp<span class="number">-4</span>],eax</span><br></pre></td></tr></table></figure>

<p>3️⃣ 当我们逆向的时候，可以通过函数头部的sub esp, x来判断这个函数有多少局部变量</p>
<p>4️⃣ 关于CPU寄存器的说明</p>
<p>​	eax： 函数的执行结果会通过eax来传递</p>
<p>​	esp： 栈顶，栈顶以下的值代表着是可以访问的局部变量。</p>
<p>​	ebp： 栈底</p>
<p>​	eip：  CPU执行的位置</p>
<p><strong>函数重载</strong>（C++内容）</p>
<p>函数重载（Function Overloading）是编程中一种允许在同一个作用域中定义多个同名函数的技术。这些函数根据其参数的个数或类型的不同，能够执行不同的操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这种是不可以的，int* a 和  int a[]其实是一样的 </span></span><br><span class="line"><span class="comment">// 函数重载使用时不能出现歧义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">ave</span>(a, b);  <span class="comment">// 这种就是不行，出现歧义了  上面两个函数都适用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ave</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">100</span>, b = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>(a, b) &lt;&lt; std::endl;  <span class="comment">// 自动转成float</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>((<span class="type">int</span>)a, (<span class="type">int</span>)b) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这地方的 转换是临时 的变量，没有固定的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不可以重载，是以值传参，不能修改内存里面的值，所以const形同虚设</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">const</span>&amp; <span class="type">int</span> a, <span class="type">const</span>&amp; <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以重载，</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">100</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c = <span class="number">20</span>, d = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>(a, b) &lt;&lt; std::endl;  <span class="comment">//  非调用第一个</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>(c, d) &lt;&lt; std::endl;  <span class="comment">//  常量执行第二个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; 函数重载的时候不能默认参数   编译器分不清</p>
<p><strong>函数模板</strong>（C++内容）</p>
<p>函数模板（Function Template）是 C++ 中的一种通用编程技术，允许程序员编写可以操作多种数据类型的函数，而无需为每种数据类型单独重写代码。函数模板通过引入模板参数，使函数的类型可以在调用时动态确定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a, type1 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt;</span><br><span class="line"><span class="function">type1 <span class="title">ave</span><span class="params">(type1 a, type1 b, type1 c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">type1 <span class="title">ave1</span><span class="params">(type1* a, type1* b, type1* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把type1当作一种类型来使用   指针  数组  都可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">ave</span>(<span class="number">12.0f</span>, <span class="number">250.0f</span>, <span class="number">35.33f</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>(<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>((<span class="type">char</span>)<span class="number">11</span>, (<span class="type">char</span>)<span class="number">12</span>, (<span class="type">char</span>)<span class="number">13</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定函数参数的模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a, type1 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">ave</span>&lt;<span class="type">int</span>&gt;(<span class="number">12.0f</span>, <span class="number">250.0f</span>, <span class="number">35.33f</span>) &lt;&lt; std::endl;  <span class="comment">// 转换成int类型了</span></span><br><span class="line">    <span class="comment">// 相当于执行下面的代码</span></span><br><span class="line">    <span class="comment">// int ave(int a, int b);   而不是 float ave(float a, float b);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载大于函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type1&gt;</span></span><br><span class="line"><span class="function">type1 <span class="title">bigger</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例外</span></span><br><span class="line"><span class="comment">//template&lt;&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">bigger</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *a &gt; *b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span>* <span class="title">bigger</span><span class="params">(<span class="type">float</span>* a, <span class="type">float</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *a &gt; *b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type1&gt;</span></span><br><span class="line"><span class="function">type1 <span class="title">ave</span><span class="params">(type1 a, type1 b, type1 c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b + c) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 本来是想着减少内存开销，传入指针，结果发现，传入的是地址</span></span><br><span class="line">    <span class="type">int</span> a&#123; <span class="number">100</span> &#125;, b&#123; <span class="number">200</span> &#125;, c&#123; <span class="number">300</span> &#125;;</span><br><span class="line">    c = *<span class="built_in">bigger</span>(&amp;a, &amp;b);</span><br><span class="line">    c = *<span class="built_in">ave</span>(&amp;a, &amp;b, &amp;c);   <span class="comment">//相当于把内存地址加起来除以3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>auto decltype</strong></p>
<p>1️⃣auto 不保留const属性  <code>const int a&#123; 10 &#125;;</code> <code>auto b = a;</code>  这里的b就是int类型 。</p>
<p>2️⃣ auto 会优先推断为值类型而非引用类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b&#123;<span class="number">200</span>&#125;;</span><br><span class="line"><span class="type">int</span>&amp; l&#123;b&#125;;</span><br><span class="line"><span class="keyword">auto</span> c = l;   <span class="comment">// 这里l还是int类型</span></span><br></pre></td></tr></table></figure>

<p>3️⃣ auto 利用函数返回值来确定类型的时候，函数会执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// ave(1,2)会执行    x的类型根据ave函数的返回类型来确定</span></span><br></pre></td></tr></table></figure>

<p>根据特性2️⃣</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// auto 拖尾函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span>-&gt;<span class="type">float</span>   <span class="comment">// 转成float类型了</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">bigger</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span>  <span class="comment">// 这里改成auto不行，会把&amp;转成int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a&#123;<span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b&#123;<span class="number">200</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 能这么写是因为返回值不是临时变量，左值</span></span><br><span class="line">    <span class="comment">// bigger(a, b) = 500;  // 比较a 和 b 哪个数大，大的 改成500;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>decltype关键字</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;&#125;;</span><br><span class="line"><span class="type">unsigned</span> b&#123;&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(a-b) x;  <span class="comment">// 相当于unsigned x;    有符号数和无符号运算，结果为无符号数</span></span><br></pre></td></tr></table></figure>

<p>如果表达式没有经历过运算，那么类型是一样的，  可以保留引用属性  （引用必须初始化）</p>
<p>（没有固定内存地址的情况）如果经历过运算了，会根据结果的类型来推断类型</p>
<p>（有固定内存地址的情况）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;<span class="number">100</span>&#125;;</span><br><span class="line"><span class="type">int</span>* pa&#123;&amp;a&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(*pa) x = a;<span class="comment">// x 是int 类型的引用</span></span><br></pre></td></tr></table></figure>

<p><img src="https://bu.dusays.com/2024/11/24/674327db2d723.png"></p>
<p><code>decltype(pa[5]) x;</code>  相当于int&amp; x    pa[5]是有地址的，只是不归我们访问而已</p>
<p><img src="https://bu.dusays.com/2024/11/24/674328e67c835.png"></p>
<p><img src="https://bu.dusays.com/2024/11/24/67432a50d20d6.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span>-&gt;<span class="title">decltype</span><span class="params">(a &gt; b ? a : b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">bigger</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>推断函数模板返回类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">ave</span><span class="params">(T2 a, T1 b)</span>   <span class="comment">// T1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回类型是由后面的决定的</span></span><br><span class="line">    <span class="built_in">ave</span>(<span class="number">100.02f</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">delctype</span><span class="params">(<span class="keyword">auto</span>)</span> <span class="title">bigger</span><span class="params">(T1&amp; a, T2&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">50000</span>;</span><br><span class="line">    <span class="comment">// float&amp; lx = b;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bigger</span>(a, b);  <span class="comment">// 结果是个float引用，但是不能指向int类型</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数模板参数的默认值</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 返回值默认为int类型, 建议写在前面</span></span><br><span class="line"><span class="comment">// 另一种写法,  可以不指定了，跟着T1 走</span></span><br><span class="line"><span class="comment">// template&lt;typename T1, typename T2, typename TR = T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR </span>= <span class="type">int</span>, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">TR <span class="title">ave</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数模板可以有非类型的模板参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type1, <span class="type">int</span> max, <span class="type">int</span> min&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AddHp</span><span class="params">(type1&amp; hp, type1 damage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hp -= damage;</span><br><span class="line">    <span class="keyword">if</span> (hp &gt; max) hp = max;</span><br><span class="line">    <span class="keyword">return</span> hp &lt; min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实践，试下这个函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> max, <span class="type">int</span> min, <span class="keyword">typename</span> type1&gt;   <span class="comment">// 建议将 非类型参数写在前面</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ChangeHp</span><span class="params">(type1&amp; hp, type1 damage)</span>  <span class="comment">// max 和 min 不是变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hp -= damage;</span><br><span class="line">    <span class="keyword">if</span> (hp &gt; max) hp = max;</span><br><span class="line">    <span class="keyword">return</span> hp &lt; min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hp = <span class="number">2500</span>;</span><br><span class="line">    <span class="comment">// const int x = 2500;</span></span><br><span class="line">    <span class="comment">// ChangHp&lt;x,1000&gt;(hp, 100);  // 这样会报错，x 是常量才可以，这也说明了max和min不是变量</span></span><br><span class="line">    <span class="built_in">ChangHp</span>&lt;<span class="number">2000</span>,<span class="number">1000</span>&gt;(hp, <span class="number">100</span>);   <span class="comment">// &lt;&gt;里面的数据需要指定</span></span><br><span class="line">    std::cout &lt;&lt; hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  指定默认值</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 指定默认值之后，在main里面就不需要&lt;&gt;来指定max  min的值了</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> max </span>= <span class="number">2000</span>, <span class="type">int</span> min = <span class="number">1000</span>, <span class="keyword">typename</span> type1&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">ChangeHp</span>(type1&amp; hp, type1 damage) </span><br><span class="line">&#123;</span><br><span class="line">    hp -= damage;</span><br><span class="line">    <span class="keyword">if</span> (hp &gt; max) hp = max;</span><br><span class="line">    <span class="keyword">return</span> hp &lt; min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hp = <span class="number">2500</span>;</span><br><span class="line">    <span class="built_in">ChangHp</span>(hp, <span class="number">100</span>);</span><br><span class="line">    std::cout &lt;&lt; hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将非类型参数写在后面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将max 和 min 转换为type1类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type1, type1 max = <span class="number">2000</span>, type1 min = <span class="number">1000</span>, &gt; type1 类型</span><br><span class="line"><span class="type">bool</span> <span class="built_in">ChangeHp</span>(type1&amp; hp, type1 damage) </span><br><span class="line">&#123;</span><br><span class="line">    hp -= damage;</span><br><span class="line">    <span class="keyword">if</span> (hp &gt; max) hp = max;</span><br><span class="line">    <span class="keyword">return</span> hp &lt; min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://bu.dusays.com/2024/11/25/6743c6535c905.png"></p>
<p><strong>处理不同元素数组的模板函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">short</span> count&gt;</span></span><br><span class="line"><span class="function">T <span class="title">ave</span><span class="params">(T(&amp;ary)[count])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T all&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i ++ )</span><br><span class="line">        all += ary[i];</span><br><span class="line">    <span class="keyword">return</span> all / count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>(a);  <span class="comment">// count的值是通过数组大小自动推导出来的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式指定模板参数</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; ave&lt;int, 5&gt;(a) &lt;&lt; std::endl;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只指定 count 的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>&lt;<span class="keyword">decltype</span>(a[<span class="number">0</span>]), <span class="number">5</span>&gt;(a) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小项目：万能排序工具</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp&#123; a &#125;;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(T* ary, <span class="type">unsigned</span> count, <span class="type">bool</span> BigSort = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">1</span>; i &lt; count; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">1</span>; i &lt; count; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> bcase = BigSort &gt; ary[i] &gt; ary[i - <span class="number">1</span>] : ary[i] &lt; ary[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (bcase) <span class="built_in">Swap</span>(ary[i], ary[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>]&#123; <span class="number">123</span>, <span class="number">343</span>, <span class="number">434</span>, <span class="number">1</span>, <span class="number">3454</span>, <span class="number">33</span>&#125;;</span><br><span class="line">    <span class="type">short</span> a1[<span class="number">6</span>]&#123; <span class="number">123</span>, <span class="number">343</span>, <span class="number">434</span>, <span class="number">1</span>, <span class="number">3454</span>, <span class="number">33</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    std::string a2[<span class="number">5</span>]&#123; <span class="string">&quot;12&quot;</span>,<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;sdf&quot;</span>,<span class="string">&quot;sesdas&quot;</span>,<span class="string">&quot;sdasd&quot;</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Sort</span>(a1, <span class="number">6</span>);</span><br><span class="line">	<span class="built_in">Sort</span>(a, <span class="number">6</span>);</span><br><span class="line">	<span class="built_in">Sort</span>(a2, <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : a)std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : a1)std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : a2)std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus05函数和栈</title>
    <url>/2024/12/11/Cplusplus05%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/</url>
    <content><![CDATA[<p>栈的本质是一段提前分配好的内存空间，主要就是用来存放临时变量！只需要管理好栈的读写就可以避免频繁的内存分配和不必要的内存浪费！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = a + <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">250</span>;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">Ave</span>(a, b);</span><br><span class="line">    c = c + d;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Add;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">Add</span>(<span class="number">250</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CPU 的寄存器：</p>
<p><code>return</code>  的值 一般使用 eax 来传递</p>
<p><img src="https://bu.dusays.com/2024/11/27/6747130a5ebff.png"></p>
<p><img src="https://bu.dusays.com/2024/11/27/674713b137197.png"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus08类</title>
    <url>/2024/12/11/Cplusplus08%E7%B1%BB/</url>
    <content><![CDATA[<p><strong>静态成员变量</strong></p>
<p>static  关键字声明一个类的静态成员变量，类的静态成员变量的特点：</p>
<p>1️⃣ 所有类的实例中，共享类中的静态成员变量</p>
<p>2️⃣ 类的静态成员变量在没有类的实例的情况下，依然可以访问</p>
<p>3️⃣ 类的静态成员变量并不完全属于类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;   <span class="comment">// 内存空间不属于类</span></span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> T::count = <span class="number">100</span>;  <span class="comment">//定义 必须加上T::</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T::cout &lt;&lt; <span class="number">350</span>;</span><br><span class="line">    T t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态成员变量的初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;  <span class="comment">// 利用inline  在类里面定义count</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="built_in">T</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T t4;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t1, t2, t3;</span><br><span class="line">    T t5;</span><br><span class="line">    std::cout &lt;&lt; t<span class="number">1.</span><span class="built_in">GetCount</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="built_in">T</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">T</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T t4;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t1, t2, t3;</span><br><span class="line">    T t5;</span><br><span class="line">    std::cout &lt;&lt; t<span class="number">1.</span><span class="built_in">GetCount</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态成员常量</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> count&#123;<span class="number">250</span>&#125;;  <span class="comment">// 有时候可以在这里定义，有时候不可以，我个人觉得在外面定义</span></span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="built_in">T</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">T</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>静态成员函数</strong></p>
<p><img src="https://bu.dusays.com/2024/12/02/674da3de88eb6.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一条</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span> <span class="comment">// const 第三条，不需要const来限定</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// hp++;  第二条  没有类的实例不能访问这个   一 二  条冲突</span></span><br><span class="line">        <span class="comment">// this-&gt;hp++;  避免访问非静态成员变量</span></span><br><span class="line">        count ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T::<span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>友元类</strong></p>
<p>友元类是一个可以访问另一个类的私有成员（<code>private</code>）和保护成员（<code>protected</code>）的类。即使是私有或保护成员，友元类也可以直接访问它们，打破了类的封装性（encapsulation）的一部分。友元类的机制为类提供了一种灵活的方式来控制哪些外部类可以访问其私有成员。</p>
<p>友元会破坏类的封装性，没有更好选择的情况下再使用友元，友元咧不是一种平等的关系，你能访问它的私有变量，它不一样能访问你的私有变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;  <span class="comment">// 默认为私有的</span></span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetMP</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; mp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t1)</span></span>;  <span class="comment">// 可以有多个友元</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t<span class="number">1.</span>hp = <span class="number">100</span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">GetMP</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span>;  <span class="comment">// 不在这里声明，那T中的T1编译器识别不出来</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;  <span class="comment">// 默认为私有的</span></span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetMP</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; mp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t1, T1&amp; t2)</span></span>;  <span class="comment">// 可以有多个友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SetMP</span><span class="params">(T&amp; t1, T1&amp; t2)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;  <span class="comment">// 默认为私有的</span></span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetMP</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; mp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t1, T1&amp; t2)</span></span>;  <span class="comment">// 可以有多个友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SetMP</span><span class="params">(T&amp; t1, T1&amp; t2)</span></span>; <span class="comment">// 放在public 或者 private 都可以</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetMP</span><span class="params">(T&amp; t1, T1&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t<span class="number">1.</span>hp = <span class="number">100</span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">GetMP</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t1, T1 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t<span class="number">1.</span>hp = <span class="number">100</span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">GetMP</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>嵌套类</strong></p>
<p>1️⃣ 用法</p>
<p>2️⃣ 作用域</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> hp;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">testx</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="keyword">enum class</span> <span class="title class_">WeaponLv</span></span><br><span class="line">	&#123;</span><br><span class="line">		normal = <span class="number">0</span>,</span><br><span class="line">		high,</span><br><span class="line">		rare,</span><br><span class="line">		myth</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Role</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		Weapon::<span class="built_in">test1</span>();</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Weapon</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tt1;</span><br><span class="line">		<span class="function">Weapon* <span class="title">ReturnW</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Weapon</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">testx</span>();  <span class="comment">// 可以访问Role静态成员函数</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Weapon</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			Role role;</span><br><span class="line">			role.hp++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">short</span> lv;</span><br><span class="line">		WeaponLv wlv;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> mp;</span><br><span class="line">	Weapon leftHands;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Role::Weapon* Role::Weapon::<span class="built_in">ReturnW</span>()  <span class="comment">// 注意作用域</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">250</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> hp;</span><br><span class="line">		<span class="type">int</span> mp;</span><br><span class="line">		<span class="type">int</span> count;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">GetHP</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			a1++;</span><br><span class="line">			<span class="comment">//x++;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	T t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问权限问题：嵌套类可以访问外层类的所有成员 ，外层类仅能访问嵌套类的共有成员</p>
<p>枚举类型也可以放进去，但有个作用域的问题</p>
<p><strong>局部类</strong></p>
<p><strong>定义在函数内的类称为局部类</strong>：局部类的定义必须写在类内、 局部类中不允许使用静态成员变量、局部类可以访问全局变量。</p>
<p>静态成员变量不能定义在类里面，定义在外面又受作用域的问题，矛盾</p>
<p>虽然有<code>inline</code>关键字， 但避免那么写    局部类都少用</p>
<p><strong>嵌套类模块化问题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Role.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// 这里不要Skill.h的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Skill</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Skill.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Role.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span>::Skill</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Role.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Skill.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>malloc 和 new 的本质区别：malloc仅仅分配内存，new除了分配内存以外还会调用构造函数</p>
<p>free() 没有调用析构函数，delete不进释放内存空间，会调用类的析构函数</p>
<p><img src="https://bu.dusays.com/2024/12/02/674dba5f2954b.png"></p>
<p><img src="https://bu.dusays.com/2024/12/02/674dba5f505ef.png"></p>
<p><img src="https://bu.dusays.com/2024/12/02/674dba5f2e452.png"></p>
<p><strong>从底层理解类</strong></p>
<p><img src="https://bu.dusays.com/2024/12/02/674dbde4a10b1.png"></p>
<p><img src="https://bu.dusays.com/2024/12/02/674dbe7601fb6.png"></p>
<p><img src="https://bu.dusays.com/2024/12/02/674dbfcc11236.png"></p>
<p><strong>类的自定义函数调用</strong></p>
<p><strong>项目</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HPMed</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Recover&#123; <span class="number">100</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> maxHp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Role</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        hp = <span class="number">1000</span>;</span><br><span class="line">        maxHp = <span class="number">3500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetHP</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;HP:&quot;</span> &lt;&lt; hp &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; maxHp&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EatMed</span><span class="params">(HPMed&amp; hpMed)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        hp += hpMed.Recover;</span><br><span class="line">        hp = hp &gt; maxHp ? maxHp : hp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role user;</span><br><span class="line">    HPMed med;</span><br><span class="line">    <span class="comment">//user = user + med;</span></span><br><span class="line">    user.<span class="built_in">GetHP</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        std::cin &gt;&gt; a;</span><br><span class="line">        user.<span class="built_in">EatMed</span>(med);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        user.<span class="built_in">GetHP</span>();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus07编译器、面向对象</title>
    <url>/2024/12/11/Cplusplus07%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><code>#define A B</code>   将标识A定义为B的别名    <code>#define 整数  int</code>       <code>整数  a&#123;&#125;;</code></p>
<p><code>#define H</code>      定义一个标识符H， 代码中的H将会被删除掉   ，<code>int H a =&gt;  int a;</code>         提高代码可阅读性的</p>
<p><code>#undef H</code>      删除这个标识符的定义，以后用不了了，  删除的顺序是根据代码编译的顺序进行的。</p>
<p><strong>定义复杂表达式的宏</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _out_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUM(X, Y) X+Y*3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELEASE(x) delete[] x, x = nullptr;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define BIGGER(X, Y) (X&gt;Y?X:Y)   // (X&gt;Y?X:Y)必须加括号，不然处理不了</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIGGER(X, Y) ((X)&gt;(Y)?(X):(Y))  <span class="comment">// 更保险的方式，全都加上括号</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW(X) std::cout&lt;&lt;X</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW1(X) std::cout&lt;&lt;#X   <span class="comment">// 处理成字符串</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW2(X,Y) void X##Y() &#123;std::cout&lt;&lt;#X;&#125;</span></span><br><span class="line"><span class="built_in">SHOW2</span>(test,<span class="number">22</span>)  <span class="comment">// 函数名字就叫test22</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">SUM</span>(<span class="number">100</span>,<span class="number">200</span>);   <span class="comment">// 100 + 200 * 3</span></span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">RELEASE</span>(a);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">BIGGER</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">SHOW</span>(<span class="number">2333</span>);   <span class="comment">//  输出</span></span><br><span class="line">    <span class="built_in">SHOW1</span>(<span class="number">233</span>sdjfkldsjf);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">test22</span>();   <span class="comment">// 就可以调用这个函数了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>const int width&#123;100&#125;;</code></p>
<p><code>#define width 1000</code></p>
<p><code>#define</code> 的方式来定义常量存在一个问题，定义的常量并不具备类型，有时候并不安全</p>
<p><strong><code>namespace</code> 命名空间</strong></p>
<p>把相关的函数，变量，结构体放进一个命名空间里面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> p&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t::v = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> p = <span class="number">200</span>;</span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; std::endl;  <span class="comment">// 输出200， 局部的</span></span><br><span class="line">    std::cout &lt;&lt; ::p &lt;&lt; std::endl;  <span class="comment">// 访问全局命名空间中的p  值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// t.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::x;  <span class="comment">// 就能访问到code.cpp 中的 x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局命名空间，所有具有链接属性的对象，只要没有定义命名空间，就默认定义在全局命名空间中，全局命名空间中的成员的访问不用显示的指定，当局部名称覆盖了全局名称时才需要显式的指定全局命名空间。</p>
<p>命名空间是可以扩展的,命名空间可以放在多个头文件里面 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// t::// 这里会出来俩变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间的声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// htc.h   头文件</span></span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> v;  <span class="comment">// 这就是声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//code.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cc.h&quot;</span></span></span><br><span class="line"><span class="comment">// int t::v&#123; 20 &#125;;  这样也是可以的 </span></span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v&#123;<span class="number">200</span>&#125;;  <span class="comment">// 声明和定义分开写了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; t::v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间的嵌套</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cc.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> v;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> hack</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">hack</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// code.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v&#123; <span class="number">200</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; t::v &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> t::hack::<span class="built_in">hack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hack!!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t::<span class="built_in">test</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>未命名的命名空间  只针对本转换单元有效（待查询资料整理）</p>
<p>命名空间的别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> a = t::hack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a::<span class="built_in">hack</span>();  <span class="comment">// 面对深度嵌套的命名空间，使用别名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">namespace</span> hack</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">hackServer</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> hServer = htd::hack;</span><br><span class="line">hServer::<span class="built_in">hackServer</span>();</span><br></pre></td></tr></table></figure>

<p><strong>未定义的命名空间和static</strong></p>
<p>未命名的命名空间是用<code>namespace &#123;&#125;</code>定义的，没有名字。</p>
<ul>
<li>任何定义在未命名命名空间中的变量、函数或类型仅在当前编译单元（文件）中可见。</li>
<li>实际上，未命名命名空间的内容被编译器视为具有<strong>内部链接</strong> （类似于<code>static</code>）。</li>
</ul>
<p>优点：提供了作用域隔离，防止名称冲突。相比static， 它可以包含多个声明(变量、函数、类型等)并形成一个逻辑分组。   建议使用未命名的命名空间代替<code>static</code>，因为它支持更复杂的结构和逻辑。</p>
<p>static 修饰的 变量或函数在当前文件中可见。</p>
<ul>
<li><code>static</code>变量和函数具有<strong>内部链接</strong> ，即它们只能在定义它们的文件中访问。</li>
<li>主要用于标记单个实体的作用域，不支持逻辑分组。</li>
</ul>
<p><img src="https://bu.dusays.com/2024/11/30/674ab5bf6fd98.png"></p>
<p><strong>预处理指令逻辑</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION 103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENDSMS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERSION==100&amp;&amp;SENDSMS   <span class="comment">// 这里可以做一些计算的  #if VERSION==(100 + 1)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION==101||SENDSMS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION==102</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION==103</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION==104</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// #if 和 #endif 是成套出现的</span></span><br></pre></td></tr></table></figure>

<p><strong>预定义宏</strong></p>
<p>标准预定义标识符  <code>__func__</code>   返回函数名字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; __func__ &lt;&lt; std::endl;  <span class="comment">// 输出ave</span></span><br><span class="line">	<span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ave</span>(<span class="number">100</span>, <span class="number">1200</span>);</span><br><span class="line">	std::cout &lt;&lt; __func__;  <span class="comment">//  输出main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; __DATE__ &lt;&lt; std::endl;  <span class="comment">// 日期</span></span><br><span class="line">std::cout &lt;&lt; __TIME__ &lt;&lt; std::endl;  <span class="comment">// 时间</span></span><br><span class="line">std::cout &lt;&lt; __func__ &lt;&lt; std::endl;  <span class="comment">// 函数名</span></span><br><span class="line">std::cout &lt;&lt; __FILE__ &lt;&lt; std::endl;  <span class="comment">// 源文件名称</span></span><br><span class="line">std::cout &lt;&lt; __LINE__ &lt;&lt; std::endl;  <span class="comment">// 当前的行号</span></span><br><span class="line">std::cout &lt;&lt; __cplusplus &lt;&lt; std::endl;  <span class="comment">// 当翻译单元为C++时，__cplusplus为一个整数文本否则为未定义</span></span><br></pre></td></tr></table></figure>

<p><img src="https://bu.dusays.com/2024/11/30/674a850dab4fb.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _CHAR_UNSIGNED</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;char unsigned&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; __FUNCDNAME__ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; __TIMESTAMP__ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; _WIN64 &lt;&lt; std::</span><br><span class="line">    <span class="comment">//  _WIN64 仅在64位下才显示</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;win32\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_DEBUG</code>  在debug模式下可以使用，发布模式下没有了</p>
<p><strong>调试</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _DBG_FOR    <span class="comment">// 通过注释这里就可以不调试 </span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DBG_FOR</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>

<p><strong>assert断言</strong></p>
<p><img src="https://bu.dusays.com/2024/11/30/674aafc634452.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一个整数\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    std::cin &gt;&gt; c;</span><br><span class="line">    <span class="built_in">assert</span>(c);   <span class="comment">// 只要是0就会弹出来</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">1000</span> / c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>static_assert</strong></p>
<p>用于编译时检查条件</p>
<p><code>static_assert(bool 表达式,&quot;错误信息&quot;);</code></p>
<p><code>static_assert(bool表达式);</code></p>
<p>与assert不同，static_assert主要是用来在编译时检查重要的条件。  因此检查的bool表达式中，只能用于常量</p>
<p><strong>面向对象的编程</strong></p>
<p><img src="https://bu.dusays.com/2024/11/30/674b125faff00.png" alt="https://bu.dusays.com/2024/11/30/674b125faff00.png"></p>
<p>类      定义了对象的属性（成员变量）和行为（成员函数）</p>
<p>对象   是类的实例化，可以用来存储数据和调用函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NPC</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> hp;</span><br><span class="line">	<span class="type">int</span> mp;</span><br><span class="line">	<span class="type">int</span> damage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MONSTER</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> hp;</span><br><span class="line">	<span class="type">int</span> mp;</span><br><span class="line">	<span class="type">int</span> damage;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ROLE</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> hp;</span><br><span class="line">	<span class="type">int</span> mp;</span><br><span class="line">	<span class="type">int</span> damage;</span><br><span class="line">	<span class="type">int</span> diamond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(NPC* acter, NPC* beacter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	beacter-&gt;hp -= acter-&gt;damage;</span><br><span class="line">	<span class="keyword">return</span> beacter-&gt;hp &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MONSTER atm&#123; <span class="number">1000</span>,<span class="number">500</span>,<span class="number">100</span>,<span class="number">6000</span> &#125;;</span><br><span class="line">	ROLE zs&#123; <span class="number">1000</span>,<span class="number">1000</span>,<span class="number">50</span>,<span class="number">1000</span> &#125;;</span><br><span class="line">	ROLE ls&#123; <span class="number">1000</span>,<span class="number">500</span>,<span class="number">100</span>,<span class="number">600</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Act</span>((NPC*)&amp;atm, (NPC*)&amp;ls);  <span class="comment">// 只进行强制类型转换就可以了，没必要写很多函数了</span></span><br><span class="line">	std::cout &lt;&lt; ls.hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一个例子</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Role.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Role.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Role::Act</span><span class="params">(Role&amp; role)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    role.hp -= damage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Role::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hpRecover = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Role* <span class="title">Role::bigger</span><span class="params">(Role* role)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> role-&gt;lv &gt; lv ? role : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Role&amp; <span class="title">Role::SetLv</span><span class="params">(<span class="type">int</span> newLv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lv = newLv;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Role&amp; <span class="title">Role::SetHp</span><span class="params">(<span class="type">int</span> newHp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hp = newHp;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Role&amp; <span class="title">Role::SetDamage</span><span class="params">(<span class="type">int</span> newDamage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    damage = newDamage;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Role.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>&amp; c = *p;</span><br><span class="line"></span><br><span class="line">    Role user;</span><br><span class="line">    Role monster;</span><br><span class="line">    user.<span class="built_in">SetLv</span>(<span class="number">100</span>).<span class="built_in">SetDamage</span>(<span class="number">50</span>).<span class="built_in">SetHp</span>(<span class="number">500</span>).<span class="built_in">bigger</span>(&amp;monster)-&gt;<span class="built_in">bigger</span>(&amp;user);</span><br><span class="line">    Role* biggerRole= user.<span class="built_in">bigger</span>(&amp;monster);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Role.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> hpRecover;</span><br><span class="line">	<span class="type">int</span> hp;</span><br><span class="line">	<span class="type">int</span> lv;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*如果inline函数的定义不在类内部，也不在头文件中，而是放在某个.cpp文件中，</span></span><br><span class="line"><span class="comment">	编译器确实可能出现问题，因为它在链接阶段无法找到该函数的实现*/</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetHp</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> damage;</span><br><span class="line">	<span class="function">Role* <span class="title">bigger</span><span class="params">(Role* role)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Act</span><span class="params">(Role&amp; role)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Role&amp; <span class="title">SetLv</span><span class="params">(<span class="type">int</span> newLv)</span></span>;</span><br><span class="line">	<span class="function">Role&amp; <span class="title">SetHp</span><span class="params">(<span class="type">int</span> newHp)</span></span>;</span><br><span class="line">	<span class="function">Role&amp; <span class="title">SetDamage</span><span class="params">(<span class="type">int</span> newDamage)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内联函数，以Role.cpp里面的函数为准，重写原则</p>
<p><strong>this指针</strong></p>
<p><code>this</code>指针是一个指向调用成员函数的对象的指针。每当你在一个类的成员函数中使用<code>this</code>时，它自动指向当前调用该成员函数的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">show</span>(); <span class="comment">// x = 10   this指针的值是对象的地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>this</strong> 指针的特点</p>
<p> · <code>this</code>指针是隐式传递给成员函数的。不需要显示地将它作为参数传递，它是C++编译器自动提供的。</p>
<p> · <code>this</code>指针是只读的。你不能修改 <code>this</code>指针本身（既不能让 <code>this</code> 指针指向其他对象），但是可以通过它访问的对象的成员。</p>
<p> · 对于非静态成员函数， <code>this</code> 指针总是存在的，而在静态成员函数中没有this指针，因为静态函数不依赖任何特定的对象。</p>
<p> · <code>this</code> 指针的类型是ClassName*， 它指向调用成员函数的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Myclass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>this-&gt;x</code> 表示当前对象的成员变量x，而x则表示函数的参数。这样可以避免成员变量与函数参数名称冲突的问题。</p>
<p><code>this</code>  指针的使用场景</p>
<p>1️⃣ 区分成员变量和局部变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2️⃣ 链式调用</p>
<p><code>this</code> 指针的返回值可以用于链式调用，常见于实现流式操作接口（比如std::string的操作）。返回<code>*this</code> 意味着返回当前对象的引用，从而可以链式调用多个方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">setX</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = val;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用，实现链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">setX</span>(<span class="number">20</span>).<span class="built_in">setX</span>(<span class="number">30</span>).<span class="built_in">show</span>();  <span class="comment">// 链式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3️⃣ this 指针的特殊情况</p>
<p><code>this</code> 指针在静态成员函数中的不存在，静态成员函数不依赖于任何特定的对象，因此它们没有<code>this</code>指针。你不能在静态成员函数中使用<code>this</code>，因为静态成员函数是类的级别上的，而不是对象的级别上的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 不能使用this指针，因为staticFunction 是静态成员函数</span></span><br><span class="line">        <span class="comment">// this-&gt; x = 10;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4️⃣ <code>this</code> 指针与 <code>const</code> 修饰符</p>
<p> · 在常量成员函数中，<code>this</code> 指针是 <code>const</code>类型的，这意味着你不能通过this指针访问的对象成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//不能修改成员变量</span></span><br><span class="line">        <span class="comment">// x = 10;  // 错误： 不能在const函数中修改对象的状态</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5️⃣ <code>this</code> 指针与<code>const</code>对象</p>
<p>对于常量对象，<code>this</code> 指针会被隐式地转换为<code>const</code> 类型，确保通过<code>this</code>指针访问的对象不会被修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printObject</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; obj.x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6️⃣ <code>this</code> 指针的返回类型</p>
<p>由于 <code>this</code> 指针的类型是当前类的指针，所以可以将它作为返回值返回。这样通常用于链式调用或在类成员函数中传递对象的引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">MyClass* <span class="title">getThis</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;  <span class="comment">// 返回当前对象的指针。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this</code>指针是C++中非常重要的特性，它允许成员函数访问当前对象的成员，并且有助于在类中实现链式调用、区分参数和成员变量等功能。理解<code>this</code>指针对于深入掌握C++至关重要，特别是在对象操作和内存管理方面。</p>
<p><strong><code>const</code></strong></p>
<p><code>const</code> 在前面说明函数返回值是<code>const</code>  ，在后面说明这个函数是<code>const</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Role.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> Role user;</span><br><span class="line"></span><br><span class="line">	Role monster;</span><br><span class="line">	<span class="type">const</span> Role* puser&#123; &amp;user &#125;;</span><br><span class="line">	<span class="comment">// puser-&gt;damage = 2;  // 常量指针不能编译</span></span><br><span class="line">	<span class="comment">// puser-&gt;    这里不能调用成员函数</span></span><br><span class="line">	puser-&gt;<span class="built_in">GetHp</span>();  <span class="comment">// GetHp()后面加上const 就可以定义了</span></span><br><span class="line">	monster.<span class="built_in">GetHp</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetHP</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// const 成员函数内部一律不可以做任何改变的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>const</code> 对象不能以任何方式改变，这是<code>const</code> 原则，在这个原则下，<code>const</code>对象只能调用<code>const</code>成员函数。</p>
<p>在<code>const</code> 成员函数下，<code>this</code>指针也变成了<code>const</code>指针。</p>
<p>成员函数是<code>const</code>的情况下，想返回引用，只能在前面加上<code>const</code>，或者不返回引用，按值来传递。</p>
<p>1️⃣ 所有没有设计修改成员变量的成员函数，一律加上<code>const</code></p>
<p>2️⃣ 利用函数重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetDamage</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// const 对象，调用这个函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetDamage</span><span class="params">()</span></span>;   <span class="comment">// 非const 对象，调用这个函数</span></span><br></pre></td></tr></table></figure>

<p><strong>const 类型转换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(Role* p)</span>   <span class="comment">// 忘记加const了， 所以下面才进行类型转换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">SetHP</span>(<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> Role user;</span><br><span class="line">    <span class="type">const</span> Role* puser&#123; &amp;user &#125;;</span><br><span class="line">    <span class="built_in">test</span>((Role*)(&amp;user));  <span class="comment">// C 语言的转换</span></span><br><span class="line">    <span class="built_in">test</span>(<span class="built_in">const_cast</span>&lt;Role*&gt;(&amp;user));   <span class="comment">// c++ 的转换</span></span><br><span class="line">    std::cout &lt;&lt; puser-&gt;<span class="built_in">GetHP</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mutable 关键字</strong></p>
<p><code>mutable</code> 关键字是一个非常特殊的修饰符，它主要用于类的数据成员上。<code>mutable</code> 的作用是允许即使在 <code>const</code> 成员函数中，也可以修改被修饰的成员变量的值。&#96;</p>
<p>1️⃣ <code>const</code> 成员函数的限制，指一个声明为 <code>const</code> 的成员函数，这意味着该成员函数承诺不会修改对象的状态，即不会修改对象的非 <code>mutable</code> 成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>&#123;    <span class="comment">// const 成员函数</span></span><br><span class="line">        x = <span class="number">10</span>;    	<span class="comment">//  错误， const 成员函数不能修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>show()</code> 被声明为 <code>const</code> 成员函数，它承诺不修改类的任何成员。因为 <code>x</code> 不是 <code>mutable</code> 成员变量，所以试图在 <code>const</code> 成员函数中修改 <code>x</code> 是不允许的，编译器会报错。</p>
<p>2️⃣  <code>mutable</code> 的作用</p>
<p><code>mutable</code> 关键字的出现就是为了允许某些特定成员变量在 <code>const</code> 成员函数中修改。这对实现缓存、延迟计算、记录日志等场景非常有用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>&#123;    <span class="comment">// const 成员函数</span></span><br><span class="line">        x = <span class="number">10</span>;    	<span class="comment">//  允许：x 是 mutable， 可以在 const 函数中修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetMP</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> mp; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetMP</span><span class="params">(<span class="type">int</span> _lv)</span> </span>&#123; lv = _lv; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> lv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t1&#123; <span class="number">100</span>,<span class="number">200</span> &#125;;  <span class="comment">// 不能初始化lv</span></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">SetMP</span>(<span class="number">109</span>);  <span class="comment">// 可以设置lv</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数在类被创建的时候自动被调用，一般用来创建新的类实例时执行初始化操作，构造函数与它所在的类同名，并且没有返回值，任何类都至少有一个构造函数；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="built_in">T</span>()  <span class="comment">// 无参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T()\n&quot;</span>;</span><br><span class="line">        hp = <span class="number">100</span>;</span><br><span class="line">        mp = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">T</span>(<span class="type">int</span> _hp, <span class="type">int</span> _mp,)  <span class="comment">// 有参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T(int,int)\n&quot;</span>;</span><br><span class="line">        hp = _hp;</span><br><span class="line">        mp = _mp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">T</span>(T&amp; t)   <span class="comment">//  留下疑问，为什么要加个引用</span></span><br><span class="line">    &#123;</span><br><span class="line">        hp = t.hp;</span><br><span class="line">        mp = t.<span class="built_in">GetMP</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t1&#123;<span class="number">100</span>, <span class="number">200</span>&#125;;   <span class="comment">// 调用有参数的构造函数</span></span><br><span class="line">    <span class="function">T <span class="title">t2</span><span class="params">(t1)</span></span>;   <span class="comment">// 调用的就是T(T&amp; t)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n.............\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; t<span class="number">1.</span>hp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t<span class="number">1.</span><span class="built_in">GetMP</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类没有明显的定义一个构造函数，那么编译器会自动的添加一个默认的构造函数，这个默认的构造函数是无参数、无返回值的函数</p>
<p><strong><code>default</code>关键字</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Role</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">Role</span>(<span class="type">int</span> _lv = <span class="number">500</span>) &#123; lv = _lv; &#125;  <span class="comment">// 如果有默认值的话编译器不能区分出来</span></span><br></pre></td></tr></table></figure>

<p>不建议这么写</p>
<p><strong><code>explicit</code> 关键字</strong></p>
<p>被 <code>explicit</code> 关键字修饰的构造函数会禁用类型转换，它可以防止编译器在进行类型转换时，自动调用某些构造函数。这是为了避免隐式类型转换（隐式构造或隐式转换）导致潜在的错误或不希望发生的行为。</p>
<p>隐式类型转换的风险</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(MyClass obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>foo(42)</code> 实际上是调用了 <code>MyClass</code> 的构造函数，并将 <code>42</code> 转换为 <code>MyClass</code> 类型对象。这种隐式转换可能是安全的，但它也可能会引入意外的行为，特别是在构造函数的逻辑较为复杂时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(MyClass obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">MyClass</span>(<span class="number">42</span>));  <span class="comment">// 必须显示的调用构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>深入理解构造函数</strong></p>
<p>使用成员初始化列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> lv;</span><br><span class="line">    <span class="type">int</span> hpRecover;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        hpRecover = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//  效率更高  某些情况下只能用这种方式初始化</span></span><br><span class="line">    <span class="built_in">ROLE</span>(<span class="type">int</span> _lv, <span class="type">int</span> _damage) : lv&#123;_lv&#125;,damage&#123;_damage&#125; &#123;&#125;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用成员函数初始化列表这样的方式构造类，要注意一个问题，即为成员赋值的顺序不是依据代码的顺序，而是成员变量在类的出现顺序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> lv;</span><br><span class="line">    <span class="type">int</span> hpRecover;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ROLE</span>(<span class="type">int</span> _lv, <span class="type">int</span> _damage) : lv&#123;_lv&#125;,damage&#123;_damage&#125;,hp&#123;_lv*<span class="number">100</span>&#125;,hpRecover&#123;lv&#125; &#123;&#125;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实际初始化的顺序</span></span><br><span class="line"><span class="comment">hp=lv*100</span></span><br><span class="line"><span class="comment">hpRecover = lv;</span></span><br><span class="line"><span class="comment">lv = _lv;</span></span><br><span class="line"><span class="comment">damage = _damage;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>委托构造函数</strong></p>
<p>它允许一个构造函数调用另一个构造函数。委托构造函数通过将其构造逻辑委托给同一类中的另一个构造函数来减少代码重复，并提高代码的可维护性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> lv;</span><br><span class="line">    <span class="type">int</span> hpRecover;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ROLE</span>():<span class="built_in">ROLE</span>(<span class="number">100</span>,<span class="number">200</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ROLE</span>(<span class="type">int</span> _lv, <span class="type">int</span> _damage):lv&#123;_lv&#125;,damage&#123;_damage&#125; &#123;&#125;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托构造函数初始化列表里不能初始化成员变量且只能调用一次同一个类的构造函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 委托构造函数：调用另一个构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">Person</span>(<span class="string">&quot;Unknown&quot;</span>, <span class="number">0</span>)  <span class="comment">// 委托之后，这里就不写name(name), age(age)这种了列表了</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p1;  <span class="comment">// 将调用默认构造函数，进而委托给带参数的构造函数</span></span><br><span class="line">    p<span class="number">1.</span><span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;  <span class="comment">// 调用带参数的构造函数</span></span><br><span class="line">    p<span class="number">2.</span><span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>副本构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Role role1;</span><br><span class="line"><span class="function">Role <span class="title">role2</span><span class="params">(role1)</span></span>;</span><br><span class="line"><span class="comment">// 编译器为类指定了一个默认的副本构造函数，我们也可以手动指定副本构造函数。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Role.h</span></span><br><span class="line"><span class="built_in">Role</span>(Role&amp; rl) </span><br><span class="line">&#123;</span><br><span class="line">    hp = rl.hp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line">user.<span class="built_in">setHP</span>(<span class="number">5000</span>);</span><br><span class="line"><span class="function">Role <span class="title">userA</span><span class="params">(user)</span></span>;  <span class="comment">// 使用我们自己做的构造函数，只拷贝hp的值</span></span><br></pre></td></tr></table></figure>

<p><code>Role(Role&amp; rl)</code>   引用问题</p>
<p>在 C++ 中，当你传递对象给函数或者在对象初始化时，如果参数类型不是引用（即传值方式），那么会发生<strong>副本创建</strong>，即编译器会调用副本构造函数来创建一个新的对象。传值会导致一次额外的复制操作，消耗额外的时间和资源。</p>
<p>使用引用类型参数（<code>Role&amp; rl</code>）可以避免这种多余的复制，直接引用原有对象。因此，副本构造函数的参数一般定义为<strong>常量引用</strong>（<code>const Role&amp; rl</code>），来避免对原对象进行修改。</p>
<p>如果副本构造函数的参数是按值传递，那么在调用副本构造函数时，编译器会尝试用这个值初始化一个新对象。这又会调用副本构造函数，而副本构造函数是用来构造副本的，这会导致递归调用，造成栈溢出。</p>
<p>通过传递引用，副本构造函数避免了重新调用自身，解决了递归调用的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Role userA = user;  <span class="comment">// userA还没有构造，把user当成参数</span></span><br><span class="line">userA = user;   <span class="comment">// 这里就不再构造函数了</span></span><br></pre></td></tr></table></figure>



<p><strong>析构函数</strong></p>
<p>用来销毁一个类，析构函数没有参数，没有返回类型，使用default来定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~类名()   <span class="comment">// 没参数就不能重载</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 空的析构函数</span></span><br><span class="line">~<span class="built_in">ROLE</span>() = <span class="keyword">default</span>;  </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* ary;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Role</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        ary = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n类被创建&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Role</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ary;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n 类被销毁&quot;</span>;   <span class="comment">// 这样写防止内存泄露</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::string 就用到这种技术</span></span><br></pre></td></tr></table></figure>

<p><strong>实现字符串类<code>hstring</code></strong></p>
<p><code>std::string</code> 设计一个类 <code>hstirng</code></p>
<p><code>hstring str(&quot;你好！&quot;);</code>    &#x2F;&#x2F; 构造函数</p>
<p><code>hstring strA(str);</code>   &#x2F;&#x2F; 副本构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* c_str;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> len;</span><br><span class="line">	<span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">length</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">short</span> len&#123;&#125;;</span><br><span class="line">		<span class="keyword">while</span> (str[len++]);</span><br><span class="line">		<span class="keyword">return</span> len;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">hstring</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		len = <span class="number">1</span>;</span><br><span class="line">		c_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">	&#123;</span><br><span class="line">		len = <span class="built_in">length</span>(str) + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//c_str = (char*)str;  // 指向了常量的内存空间,所以运行起来会出错</span></span><br><span class="line">		c_str = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">		<span class="built_in">memcpy</span>(c_str, str, len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">char</span>* <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c_str;   </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">hstring</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">hstring <span class="title">str</span><span class="params">(<span class="string">&quot;你好！！&quot;</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; str.<span class="built_in">Show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>私有成员变量的访问</p>
<p>在 C++ 中，类的私有变量（private members）只能在类的内部进行访问，不能直接从类的外部进行访问。私有成员是为了实现数据封装（Encapsulation）这一面向对象编程的基本原则，目的是隐藏类的内部实现细节，只允许通过公共接口（如公共成员函数）来访问和修改私有数据。</p>
<h3 id="1-如何访问类的私有成员"><a href="#1-如何访问类的私有成员" class="headerlink" title="1. 如何访问类的私有成员"></a>1. <strong>如何访问类的私有成员</strong></h3><p>C++ 提供了一些方法来访问和修改类的私有变量：</p>
<h4 id="1-1-通过公共成员函数访问私有成员"><a href="#1-1-通过公共成员函数访问私有成员" class="headerlink" title="1.1 通过公共成员函数访问私有成员"></a>1.1 <strong>通过公共成员函数访问私有成员</strong></h4><p>最常见的方式是通过公共成员函数（通常称为 getter 和 setter）来访问或修改私有成员。类的私有成员可以通过这些函数提供对外接口。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp复制代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 私有成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公共构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">privateVar</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter：访问私有成员变量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPrivateVar</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateVar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter：修改私有成员变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPrivateVar</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        privateVar = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;  <span class="comment">// 创建对象并初始化私有成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Private Var: &quot;</span> &lt;&lt; obj.<span class="built_in">getPrivateVar</span>() &lt;&lt; endl;  <span class="comment">// 通过公共成员函数访问私有成员</span></span><br><span class="line">    obj.<span class="built_in">setPrivateVar</span>(<span class="number">100</span>);  <span class="comment">// 修改私有成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Private Var: &quot;</span> &lt;&lt; obj.<span class="built_in">getPrivateVar</span>() &lt;&lt; endl;  <span class="comment">// 再次访问修改后的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，私有成员变量 <code>privateVar</code> 只能通过公共的 getter 函数 <code>getPrivateVar()</code> 和 setter 函数 <code>setPrivateVar()</code> 访问和修改。这是实现类的<strong>数据封装</strong>的一种常见方法。</p>
<h4 id="1-2-通过友元函数（Friend-Function）访问私有成员"><a href="#1-2-通过友元函数（Friend-Function）访问私有成员" class="headerlink" title="1.2 通过友元函数（Friend Function）访问私有成员"></a>1.2 <strong>通过友元函数（Friend Function）访问私有成员</strong></h4><p>除了通过公共成员函数外，还可以通过定义<strong>友元函数</strong>来访问私有成员。友元函数不是类的成员函数，但它可以访问类的私有成员。友元函数被声明为类的朋友，拥有对该类私有成员的访问权限。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp复制代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 私有成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">privateVar</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">showPrivateVar</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPrivateVar</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Private Var: &quot;</span> &lt;&lt; obj.privateVar &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showPrivateVar</span>(obj);  <span class="comment">// 通过友元函数访问私有成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>showPrivateVar()</code> 是 <code>MyClass</code> 类的友元函数，它可以直接访问 <code>MyClass</code> 的私有成员 <code>privateVar</code>。</p>
<h4 id="1-3-通过友元类（Friend-Class）访问私有成员"><a href="#1-3-通过友元类（Friend-Class）访问私有成员" class="headerlink" title="1.3 通过友元类（Friend Class）访问私有成员"></a>1.3 <strong>通过友元类（Friend Class）访问私有成员</strong></h4><p>除了友元函数，C++ 还允许整个类成为另一个类的友元类。友元类可以访问被它声明为友元的类的私有成员。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp复制代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherClass</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">privateVar</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 AnotherClass 为友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">AnotherClass</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPrivateVar</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Private Var: &quot;</span> &lt;&lt; obj.privateVar &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    AnotherClass anotherObj;</span><br><span class="line">    anotherObj.<span class="built_in">showPrivateVar</span>(obj);  <span class="comment">// 通过友元类访问私有成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>AnotherClass</code> 是 <code>MyClass</code> 的友元类，因此 <code>AnotherClass</code> 可以直接访问 <code>MyClass</code> 的私有成员 <code>privateVar</code>。</p>
<h4 id="1-4-通过指针和引用访问私有成员"><a href="#1-4-通过指针和引用访问私有成员" class="headerlink" title="1.4 通过指针和引用访问私有成员"></a>1.4 <strong>通过指针和引用访问私有成员</strong></h4><p>如果有指向对象的指针或引用，并且你能通过公共接口访问私有成员，那么你就可以通过这些接口来访问私有成员。值得注意的是，直接通过指针或引用访问私有成员是不可行的，除非使用 <code>friend</code> 函数或者 <code>getter</code> 和 <code>setter</code>。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp复制代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">privateVar</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPrivateVar</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateVar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    MyClass* ptr = &amp;obj;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Private Var via pointer: &quot;</span> &lt;&lt; ptr-&gt;<span class="built_in">getPrivateVar</span>() &lt;&lt; endl;  <span class="comment">// 通过指针访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. <strong>总结</strong></h3><ul>
<li><strong>私有成员变量</strong>（private members）是 C++ 中类的一部分，只能在类内部访问，不允许外部直接访问。</li>
<li><strong>公共成员函数</strong>（getter&#x2F;setter）通常是访问私有成员的推荐方式。通过提供控制访问的接口，可以保护数据的安全性和一致性。</li>
<li><strong>友元函数</strong>和<strong>友元类</strong>允许外部的函数或类访问该类的私有成员，但这种方式通常会打破封装性，因此应该谨慎使用。</li>
<li>在实际应用中，通常建议将类的成员变量设为私有，并通过公共接口（getter、setter）进行访问和修改，以确保数据的有效性和安全性。</li>
</ul>
<p>总之，访问类的私有变量应该遵循<strong>封装性</strong>的原则，避免直接在外部访问类的私有数据，而是通过设计好的接口来进行操作</p>
<p>在 C++ 中，<code>=</code> 运算符用于赋值操作，但是在不同的上下文中，<code>=</code> 运算符的含义和行为是不同的。你提到的两种情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp复制代码</span></span><br><span class="line">Role userA = user; <span class="comment">// 这种形式是复制初始化</span></span><br><span class="line">userA = user;       <span class="comment">// 这种形式是赋值操作</span></span><br></pre></td></tr></table></figure>

<p>这两者之间有很大的区别，我们将逐一分析它们的含义和不同之处。</p>
<h3 id="1-Role-userA-user-——-复制初始化（Copy-Initialization）"><a href="#1-Role-userA-user-——-复制初始化（Copy-Initialization）" class="headerlink" title="1. Role userA = user; —— 复制初始化（Copy Initialization）"></a>1. <code>Role userA = user;</code> —— <strong>复制初始化</strong>（Copy Initialization）</h3><p>这行代码属于<strong>复制初始化</strong>（Copy Initialization），它通常会调用<strong>副本构造函数</strong>。它的执行过程如下：</p>
<ul>
<li>**首先创建一个新对象 <code>userA</code>**，并用 <code>user</code> 对象初始化它。</li>
<li>在这个过程中，<strong>副本构造函数</strong>会被调用，通常情况下是 <code>Role(const Role&amp; user)</code>。</li>
</ul>
<p>也就是说，<code>Role userA = user;</code> 实际上是通过调用类的副本构造函数来构造 <code>userA</code> 对象的副本。这种赋值形式会复制 <code>user</code> 对象的状态到 <code>userA</code>。</p>
<h3 id="副本构造函数的工作流程："><a href="#副本构造函数的工作流程：" class="headerlink" title="副本构造函数的工作流程："></a>副本构造函数的工作流程：</h3><ul>
<li>调用副本构造函数创建 <code>userA</code>。</li>
<li>将 <code>user</code> 对象的成员变量的值复制给 <code>userA</code>。</li>
<li>这通常会涉及成员的深拷贝（如果类中有动态分配内存等需要处理的资源）。</li>
</ul>
<h3 id="2-userA-user-——-赋值操作（Assignment）"><a href="#2-userA-user-——-赋值操作（Assignment）" class="headerlink" title="2. userA = user; —— 赋值操作（Assignment）"></a>2. <code>userA = user;</code> —— <strong>赋值操作</strong>（Assignment）</h3><p>这行代码属于<strong>赋值操作</strong>（Assignment），它会调用对象的<strong>赋值运算符</strong>。赋值运算符用于将一个已有对象的状态赋值给另一个对象。执行过程如下：</p>
<ul>
<li>这里 <code>userA</code> 是已经存在的对象，而 <code>user</code> 是另一个对象。</li>
<li><code>userA = user;</code> 会调用类的赋值运算符，通常是 <code>Role&amp; operator=(const Role&amp; user)</code>，该运算符用于将 <code>user</code> 对象的状态复制到 <code>userA</code> 中。</li>
</ul>
<h3 id="赋值运算符的工作流程："><a href="#赋值运算符的工作流程：" class="headerlink" title="赋值运算符的工作流程："></a>赋值运算符的工作流程：</h3><ul>
<li>如果类的赋值运算符已定义，<code>operator=</code> 会被调用。</li>
<li>它会将 <code>user</code> 对象中的数据成员赋值给 <code>userA</code>，并可能涉及内存管理（例如，释放已有资源、分配新资源等）。</li>
<li>如果没有定义自定义的赋值运算符，编译器会提供一个默认的赋值运算符，该默认版本执行逐个成员的赋值操作。</li>
</ul>
<h3 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h3><ol>
<li><strong>操作对象不同：</strong><ul>
<li><code>Role userA = user;</code> 是创建一个新的对象 <code>userA</code> 并初始化它，这个过程调用的是副本构造函数。</li>
<li><code>userA = user;</code> 是将已经存在的对象 <code>userA</code> 赋值为 <code>user</code>，这个过程调用的是赋值运算符。</li>
</ul>
</li>
<li><strong>调用的函数不同：</strong><ul>
<li><code>Role userA = user;</code> 调用的是类的<strong>副本构造函数</strong>，它在创建新对象时用于初始化。</li>
<li><code>userA = user;</code> 调用的是类的<strong>赋值运算符</strong>，它用于将一个已存在对象的值复制到另一个已存在对象。</li>
</ul>
</li>
<li><strong>创建新对象与赋值对象：</strong><ul>
<li>在 <code>Role userA = user;</code> 中，<code>userA</code> 是通过副本构造函数创建的一个新对象。</li>
<li>在 <code>userA = user;</code> 中，<code>userA</code> 已经存在，它的内容会被替换为 <code>user</code> 的内容。</li>
</ul>
</li>
<li><strong>效率考虑：</strong><ul>
<li>副本构造函数通常用于创建新对象，因此它需要分配内存并初始化对象。</li>
<li>赋值运算符通常在对象已经存在的情况下执行，它会处理已有对象的资源，可能会包括释放资源、重新分配内存等操作。</li>
</ul>
</li>
</ol>
<h3 id="深入理解赋值运算符与副本构造函数"><a href="#深入理解赋值运算符与副本构造函数" class="headerlink" title="深入理解赋值运算符与副本构造函数"></a>深入理解赋值运算符与副本构造函数</h3><p>为了进一步理解它们的行为，我们可以看一下副本构造函数和赋值运算符的实现。</p>
<h4 id="副本构造函数"><a href="#副本构造函数" class="headerlink" title="副本构造函数"></a>副本构造函数</h4><p>副本构造函数的目标是创建一个新对象，它接受一个对象作为参数，并用该对象的内容初始化新对象。典型的副本构造函数实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpp复制代码class Role &#123;</span><br><span class="line">public:</span><br><span class="line">    Role(const Role&amp; other) &#123;</span><br><span class="line">        // 通过 other 来初始化当前对象</span><br><span class="line">        this-&gt;name = other.name;  // 假设是简单的成员复制</span><br><span class="line">        this-&gt;age = other.age;</span><br><span class="line">        // 如果有动态内存分配，需要深拷贝</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符用于将一个已存在的对象的状态赋值给另一个已存在的对象。典型的赋值运算符实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpp复制代码class Role &#123;</span><br><span class="line">public:</span><br><span class="line">    Role&amp; operator=(const Role&amp; other) &#123;</span><br><span class="line">        if (this != &amp;other) &#123;  // 防止自我赋值</span><br><span class="line">            this-&gt;name = other.name;</span><br><span class="line">            this-&gt;age = other.age;</span><br><span class="line">            // 如果有动态内存分配，确保释放旧的资源并分配新资源</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>Role userA = user;</code> 使用的是<strong>副本构造函数</strong>，其作用是创建一个新的对象 <code>userA</code> 并用 <code>user</code> 初始化它。</li>
<li><code>userA = user;</code> 使用的是<strong>赋值运算符</strong>，其作用是将已有对象 <code>user</code> 的内容赋值给已有对象 <code>userA</code>。</li>
</ul>
<p>两者的主要区别在于：副本构造函数负责新对象的创建并进行初始化，而赋值运算符负责已有对象的内容赋值。因此，它们各自有不同的性能和功能特点，适用于不同的情境。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus10继承</title>
    <url>/2024/12/11/Cplusplus10%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p><strong>继承的概念</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base<span class="comment">//公有继承</span></span><br><span class="line">&#123;&#125;；</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive2</span>:<span class="keyword">protected</span> Base <span class="comment">//保护继承</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive3</span>:<span class="keyword">private</span> Base<span class="comment">//私有继承</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="comment">//上面的代码中，Derive，Derive2，Derive3都继承自Base基类</span></span><br><span class="line"><span class="comment">//区别就是继承方式不同</span></span><br></pre></td></tr></table></figure>

<p><strong>多继承</strong></p>
<p>如果省略继承方式，默认为<code>private</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,....</span><br><span class="line">&#123;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p><img src="https://bu.dusays.com/2024/12/07/6753b6c38f762.png"></p>
<p>private 和 protected 区别：类继承，private无法被访问  protected可以被访问。</p>
<p>继承的时候，私有变量是占内存空间的，但是没办法访问。。。</p>
<p><strong>继承中的访问控制</strong></p>
<p><img src="https://bu.dusays.com/2024/12/07/6753c254715ca.png"></p>
<p><img src="https://bu.dusays.com/2024/12/07/6753c2ca2a6ed.png"></p>
<p><img src="https://bu.dusays.com/2024/12/07/6753c3c88b103.png"></p>
<p>一般来说，尽量设计类的成员变量为private，如果需要访问这些成员变量，应该提供setter以及getter函数。</p>
<p><strong>继承中的构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mapObject</span> :<span class="keyword">public</span> object</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">actObject</span> :<span class="keyword">public</span> mapObject</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 构造顺序为object-&gt;mapObject-&gt;actObject</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="built_in">object</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;object was created\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">object</span>(<span class="type">const</span> object&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;object was created by copy\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mapObject</span> :<span class="keyword">public</span> object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mapId;</span><br><span class="line">	<span class="built_in">mapObject</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot; mapObject was created\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mapObject</span>(<span class="type">const</span> mapObject&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot; mapObject was created by copy\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mapObject</span>(<span class="type">int</span> id) :mapId&#123; id &#125;</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">actObject</span> :<span class="keyword">public</span> mapObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> damage;</span><br><span class="line">	<span class="comment">// 不能加上mapId  因为现在还没有构造，不认为mapId是actObject的成员</span></span><br><span class="line">	<span class="built_in">actObject</span>():mapObject&#123;<span class="number">100</span>&#125;,damage&#123;<span class="number">100</span>&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 可以在里面写</span></span><br><span class="line">		mapId = <span class="number">3939</span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot; actObject was created\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// mapObject&#123;obj&#125;没有做类型转换就传进去了</span></span><br><span class="line">	<span class="built_in">actObject</span>(<span class="type">const</span> actObject&amp; obj):mapObject&#123;obj&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;actObject&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	actObject obj&#123;&#125;;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	actObject obj2 = obj;  <span class="comment">// 副本构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>继承构造函数</strong></p>
<p>允许派生类从基类继承构造函数。这意味着派生类可以使用基类的构造函数来初始化从基类继承来的数据成员，而不需要在派生类中重新定义类似的构造函数（默认构造函数和副本构造函数无法继承）</p>
<p>语法：<code>using &lt;基类名称&gt;::&lt;基类名称&gt;;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="built_in">object</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;object was created\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">object</span>(<span class="type">const</span> object&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;object was created by copy\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mapObject</span> :<span class="keyword">public</span> object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mapId;</span><br><span class="line">	<span class="built_in">mapObject</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot; mapObject was created\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mapObject</span>(<span class="type">const</span> mapObject&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot; mapObject was created by copy\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mapObject</span>(<span class="type">int</span> id) :mapId&#123; id &#125;</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mapObject</span>(<span class="type">int</span> id, <span class="type">int</span> id2) :mapId&#123; id &#125;</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">actObject</span> :<span class="keyword">public</span> mapObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 这样就继承了mapObject中的构造函数   但是默认构造函数、副本构造函数没办法继承</span></span><br><span class="line">	<span class="keyword">using</span> mapObject::mapObject;</span><br><span class="line">	<span class="type">int</span> damage;</span><br><span class="line">	<span class="comment">// 不能加上mapId  因为现在还没有构造，不认为mapId是actObject的成员</span></span><br><span class="line">	<span class="built_in">actObject</span>():mapObject&#123;<span class="number">100</span>&#125;,damage&#123;<span class="number">100</span>&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 可以在里面写</span></span><br><span class="line">		mapId = <span class="number">3939</span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot; actObject was created\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// mapObject&#123;obj&#125;没有做类型转换就传进去了</span></span><br><span class="line">	<span class="built_in">actObject</span>(<span class="type">const</span> actObject&amp; obj):mapObject&#123;obj&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;actObject&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	actObject obj&#123;<span class="number">200</span>&#125;;</span><br><span class="line">	actObject objx&#123; <span class="number">200</span>,<span class="number">300</span> &#125;;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	actObject obj2 = obj;  <span class="comment">// 副本构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承中的析构函数与重名问题</strong></p>
<p>构造的时候由基类开始构造的，析构的时候恰恰相反，先析构派生类的</p>
<p>继承中的成员变量名称重复的问题</p>
<p>1️⃣ 函数名相同，参数不同</p>
<p>​	using 基类::函数名</p>
<p>不会出错，有个作用域的问题，不存在变量名重复的问题，访问的时候 使用作用域的符号 <code>object::x</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mapObject MAP;</span><br><span class="line">MAP.x = <span class="number">2500</span>;</span><br><span class="line">MAP.object::x = <span class="number">3500</span>; <span class="comment">// 使用作用域来解决这个问题</span></span><br></pre></td></tr></table></figure>

<p>2️⃣ 函数名相同，参数相同</p>
<p>​	基类::函数名</p>
<p>函数存在一个重载的问题，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数不同名字相同   直接 在派生类里面引入函数</span></span><br><span class="line"><span class="keyword">using</span> object::showX;</span><br><span class="line"><span class="comment">// 不引入的话会被覆盖掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果基类和派生类的函数名参数以及返回类型都一样， using已经区分不出来了，只能通过作用域来区别</span></span><br><span class="line"><span class="comment">// object类</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ShowX</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapObject 类</span></span><br><span class="line"><span class="keyword">using</span> object::showX;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ShowX</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// actObject 类</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ShowX</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line">mapObject MAP:</span><br><span class="line">MAP.<span class="built_in">ShowX</span>(<span class="number">1500</span>);  <span class="comment">// 调用派生类中的函数</span></span><br><span class="line">MAP.object::<span class="built_in">ShowX</span>(<span class="number">2500</span>);  <span class="comment">// 调用基类中的函数</span></span><br><span class="line"></span><br><span class="line">actObject obj;</span><br><span class="line">obj.<span class="built_in">ShowX</span>(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">obj.mapObject::<span class="built_in">ShowX</span>(<span class="number">33</span>);</span><br><span class="line">obj.mapObject::object::<span class="built_in">ShowX</span>(<span class="number">44</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接调用,没什么层次感</span></span><br><span class="line">obj.object::<span class="built_in">ShowX</span>(<span class="number">55</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接这么操作即可</span></span><br></pre></td></tr></table></figure>

<p><strong>多重继承问题</strong></p>
<p>多重继承带来的重复继承的问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bite</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Wolf Bite!\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Wolf eat!\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Man eat!\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WolfMan</span> :<span class="keyword">public</span> Wolf, <span class="keyword">public</span> Man</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Change</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		IsWolf = !IsWolf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (IsWolf) Wolf::<span class="built_in">eat</span>();</span><br><span class="line">		<span class="keyword">else</span> Man::<span class="built_in">eat</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">bool</span> IsWolf = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WolfMan Jack;</span><br><span class="line">	Jack.<span class="built_in">bite</span>();</span><br><span class="line">	Jack.<span class="built_in">eat</span>();</span><br><span class="line">	Jack.<span class="built_in">Change</span>();  <span class="comment">// 变身</span></span><br><span class="line">	Jack.<span class="built_in">eat</span>();   <span class="comment">//  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>派生类之间的内存并不是重叠的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class MoveObject</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WolfMan Jack;</span><br><span class="line">	Jack.<span class="built_in">bite</span>();</span><br><span class="line">	Jack.Wolf::x = <span class="number">250</span>;</span><br><span class="line">	Jack.Wolf::y = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; Jack.Wolf::x &lt;&lt; std::endl;  <span class="comment">// 250</span></span><br><span class="line">	std::cout &lt;&lt; Jack.Man::x &lt;&lt; std::endl;  <span class="comment">// -858993460</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>虚基类</strong>，如果发现已经继承一次了，下次就不会再继承的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class Man :public virtual MoveObject   这样就是虚基类</span></span><br><span class="line"><span class="comment">// class Wolf:public virtual MoveObject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WolfMan Jack;</span><br><span class="line">	Jack.<span class="built_in">bite</span>();</span><br><span class="line">	Jack.Wolf::x = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; Jack.Wolf::x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; Jack.x &lt;&lt; std::endl;    <span class="comment">// 这三个都是指向的一个x</span></span><br><span class="line">	std::cout &lt;&lt; Jack.Man::x &lt;&lt; std::endl;  <span class="comment">// 虚基类，这样都是250，它俩x指向的是同一个地方，没有歧义了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从内存的角度来理解继承</strong></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus11多态</title>
    <url>/2024/12/11/Cplusplus11%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p><strong>多态概念</strong></p>
<p>多态是面向对象编程中的一个重要概念，它允许在基类的指针或引用指向派生类对象时，调用不同的函数实现。换句话说，多态是指同一接口在不同对象中有不同的实现方式。</p>
<p>多态的基本分类：</p>
<p>①  编译时多态（静态多态）：通过函数重载和运算符重载来实现。</p>
<p>② 运行时多态 （动态多态）：通过继承和虚函数来实现。</p>
<p>对象多态</p>
<p>① 向上转型   父类&#x3D;&#x3D;&gt;子类  人是动物 </p>
<p>② 向下转型   子类&#x3D;&#x3D;&gt;父类  动物是人  相当于用子类代替父类  （大神和沙雕之间二象性）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 30多态概念.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>  age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Money;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Do it~!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Human laow&#123;&#125;;</span><br><span class="line">    laow.age = <span class="number">50</span>;</span><br><span class="line">    laow.Money = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上转型</span></span><br><span class="line">    <span class="comment">//Animal anm = laow;  // 可能发生内存切片的问题</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; anm.age &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// 使用指针,没有内存截断问题</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//Human* human = anm1;  // human的成员变量要比anm1多</span></span><br><span class="line">    Animal* anm1 = &amp;laow;</span><br><span class="line">    <span class="comment">// 向下转型   更大的目的是调用里面的函数</span></span><br><span class="line">    Human* human = (Human*)anm1;</span><br><span class="line"></span><br><span class="line">    human-&gt;<span class="built_in">doit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法多态</strong></p>
<p>①  静态多态： 函数重载、函数模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>  age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Money;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Do it~!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BeAct</span><span class="params">(Human* R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BeAct</span><span class="params">(Animal* anm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Human laow;</span><br><span class="line">    Animal dog;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BeAct</span>(&amp;laow);</span><br><span class="line">    <span class="built_in">BeAct</span>(&amp;dog);  <span class="comment">// 静态多态   编译的时候决定使用哪个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②  动态多态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 30多态概念.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>  age;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BeAct</span><span class="params">(Animal* anm)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;动物被攻击！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Money;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Do it~!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BeAct</span><span class="params">(Animal* anm)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;人物被攻击！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Human laow;</span><br><span class="line">    Animal dog;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    Animal* bA;</span><br><span class="line">    std::cin &gt;&gt; id;</span><br><span class="line">    <span class="keyword">if</span> (id)</span><br><span class="line">    &#123;</span><br><span class="line">        bA = &amp;dog;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> bA = &amp;laow;</span><br><span class="line">    bA-&gt;<span class="built_in">BeAct</span>(&amp;dog);  <span class="comment">// 编译的时候不确定，就叫做动态多态 ！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>virtual关键字</code></strong></p>
<p>它是一个在基类中声明，并且希望在派生类中重写（或覆盖）的方法。通过虚函数，可以实现多态性，使得程序能够在运行时根据对象的实际类型来调用适当的函数，而不是在编译时就决定调用哪个函数。</p>
<p><img src="https://bu.dusays.com/2024/12/08/67550c89eea41.png"></p>
<p>override 后缀可以强制要求检查函数是重载</p>
<p>final 后缀可以终止函数的重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 31多态虚函数.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="comment">// virtual只能放在类内部声明</span></span><br><span class="line">    <span class="comment">// 不加上virtual 就是静态绑定</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 如果这里设置成private，那么这个函数在派生类里面用不了</span></span><br><span class="line"><span class="comment">// private:</span></span><br><span class="line">    <span class="comment">// 虚函数在派生类和基类中的返回值要求基本一致，但是当返回类型为类类型的指针和引用时除外</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MoveObject* <span class="title">Move1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveObject::Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    y++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPCObject</span>:<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这种不是覆盖   而是动态绑定</span></span><br><span class="line">    <span class="comment">// 不重写 也能运行，因为继承了基类的Move函数，调用基类中的Move函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是NPC\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//void Move(int a);  // 如果参数不一样，那就是一个正常的函数</span></span><br><span class="line">    <span class="comment">// 如果这么写的话，那么调用的就是MoveObject中的Move函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数在派生类和基类中的返回值要求基本一致，但是当返回类型为类类型的指针和引用时除外</span></span><br><span class="line">    <span class="comment">// MoveObject派生除了NPCObject，那么这里可以用MoveObject或者NPCObject</span></span><br><span class="line">    <span class="comment">// 如果NPCObject类不再派生的话，后面加上final可以</span></span><br><span class="line">    <span class="function">NPCObject* <span class="title">Move1</span><span class="params">()</span>   <span class="comment">// 协变</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*只要是派生类的虚函数都要加上override关键字*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是怪物\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">MonsterObject* <span class="title">Move1</span><span class="params">()</span>   <span class="comment">// 协变</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是以前的写法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">void Move(MonsterObject* obj)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    obj-&gt;Move();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void Move(NPCObject* obj)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    obj-&gt;Move();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在多态的写法， 只写一个基类即可</span></span><br><span class="line"><span class="comment">// 调用类的对象时无法使用虚函数的，必须使用基类指针来实现虚函数的调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写调用的是MoveObject中的Move</span></span><br><span class="line"><span class="comment">/*void Move(MoveObject obj)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    obj.Move();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">// 引用的本质也是个指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(MoveObject&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MonsterObject snake;</span><br><span class="line">    NPCObject zsf;</span><br><span class="line">    <span class="comment">// 如果没有virtual，那么就是静态绑定，什么都不会输出</span></span><br><span class="line">    <span class="comment">// 调用的是MoveObject 中的 Move函数</span></span><br><span class="line">    <span class="built_in">Move</span>(snake);</span><br><span class="line">    <span class="built_in">Move</span>(zsf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建议虚函数做成私有的，不破坏封装，可以通过基类指针访问</span></span><br></pre></td></tr></table></figure>

<p><strong>虚函数详解</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚函数详解.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MoveObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数，先构造基类再构造派生类</span></span><br><span class="line">        <span class="comment">//  派生类还没有构造，所以调用的就是MoveObject中的Move</span></span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MoveObject Moving~\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 相当于this-&gt;Move()</span></span><br><span class="line">        <span class="comment">// Move又是一个虚函数，所以调用的就是下面MonsterObject中的Move函数</span></span><br><span class="line">        <span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MoveObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 只能做静态绑定，调用基类中的Move函数</span></span><br><span class="line">        <span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Monster Moving\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MonsterObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        MoveObject::<span class="built_in">test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MonsterObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先析构派生类  再析构基类  </span></span><br><span class="line">        <span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 面试重点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MonsterObject snake;</span><br><span class="line">    <span class="comment">// 调用的是Monster中的Move</span></span><br><span class="line">    snake.<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用虚函数基类版本</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MoveObject::<span class="built_in">Move</span>();  <span class="comment">// 这样就能调用基类版本的Move函数了</span></span><br></pre></td></tr></table></figure>

<p><strong>默认实参在虚函数重点错误</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AutoMove</span><span class="params">(<span class="type">int</span> step = <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;auto move&quot;</span> &lt;&lt; step &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AutoMove</span><span class="params">(<span class="type">int</span> step = <span class="number">3</span>)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 编译的时候已经决定了step的值,在这里改没什么用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~~~~~~auto move&quot;</span> &lt;&lt; step &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main()</span></span><br><span class="line">MonsterObject snake;</span><br><span class="line"></span><br><span class="line">MoveObject* p = &amp;snake;</span><br><span class="line">p-&gt;<span class="built_in">AutoMove</span>();</span><br><span class="line"><span class="comment">// 调用的是派生类的AutoMove  但是step的值在编译的时候就已经确定了，在派生类里面改是没有用的</span></span><br></pre></td></tr></table></figure>

<p><strong>释放含有虚函数的派生对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚函数详解.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MoveObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MoveObject Moving~\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AutoMove</span><span class="params">(<span class="type">int</span> step = <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;auto move&quot;</span> &lt;&lt; step &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MoveObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Moveobj析构函数！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数中没有内容的话可以换种写法</span></span><br><span class="line">    <span class="comment">// virtual ~MoveObject() = default;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Monster Moving\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MonsterObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        MoveObject::<span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AutoMove</span><span class="params">(<span class="type">int</span> step = <span class="number">3</span>)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 编译的时候已经决定了step的值,在这里改没什么用</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~~~~~~auto move&quot;</span> &lt;&lt; step &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MonsterObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Monsterobj析构函数！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">Move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 面试重点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// MonsterObject snake;</span></span><br><span class="line"></span><br><span class="line">    MoveObject* p = <span class="keyword">new</span> <span class="built_in">MonsterObject</span>();</span><br><span class="line">    p-&gt;<span class="built_in">AutoMove</span>();</span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 触发析构函数，先析构派生类再析构基类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数不是虚函数，所以调用MoveObject中的析构函数</span></span><br><span class="line">    <span class="comment">//p-&gt;~MoveObject()</span></span><br><span class="line">    <span class="comment">// 但是没有释放内存，造成内存泄露，所以做一个虚析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类里面，析构函数和构造函数是静态绑定，其余都是动态绑定的。</p>
<p><strong>对象多态详解</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 33对象多态详解.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*virtual*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPCObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> :<span class="keyword">public</span> MonsterObject</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> :<span class="keyword">public</span> MonsterObject</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WolfMan</span> :<span class="keyword">public</span> Wolf,<span class="keyword">public</span> MoveObject,<span class="keyword">public</span> Man</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MonsterObject monster;</span><br><span class="line">    MoveObject* _move = &amp;monster;  <span class="comment">// 隐式类型转换，向上转型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// _move = new MoveObject();</span></span><br><span class="line">    <span class="comment">// 编译器不确定_pmonster指向的是什么</span></span><br><span class="line">    <span class="comment">// MonsterObject* _pmonster = _move; // 隐式类型转换不被允许  向下转型不允许</span></span><br><span class="line">    <span class="comment">//可以强制，但是基类得是可以访问的才行</span></span><br><span class="line">    MonsterObject* _pmonster = (MonsterObject*)_move; <span class="comment">// 强制类型转换  向下转换</span></span><br><span class="line">    MonsterObject* _pmonsterA = <span class="built_in">static_cast</span>&lt;MonsterObject*&gt;(_move); <span class="comment">// 静态强制类型转换</span></span><br><span class="line">    <span class="comment">// 虚基类不能强制转换，类是虚拟的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    WolfMan wolfman;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* ptr = &amp;wolfman;</span><br><span class="line">    Wolf* pwlf = &amp;wolfman;</span><br><span class="line">    <span class="comment">// Man* pman = &amp;wolfman;</span></span><br><span class="line">    <span class="comment">// 存在类型转换</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr: &quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pwlf: &quot;</span> &lt;&lt; pwlf &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;pman: &quot; &lt;&lt; pman &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">void</span>* ptr1 = &amp;wolfman;</span><br><span class="line">    Wolf* pwlf1 = (Wolf*)ptr1;  <span class="comment">// void* =&gt; Wolf*</span></span><br><span class="line">    <span class="comment">//Man* pman1 = (Man*)ptr1;  // 指针   类型 和内存地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1: &quot;</span> &lt;&lt; ptr1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pwlf1: &quot;</span> &lt;&lt; pwlf1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;pman1: &quot; &lt;&lt; pman1 &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">void</span>* ptr2 = &amp;wolfman;</span><br><span class="line">    Wolf* pwlf2 = (Wolf*)&amp;wolfman;  <span class="comment">// void* =&gt; Wolf*  Wolfman*=&gt;Wolf</span></span><br><span class="line">    <span class="comment">//Man* pman2 = (Man*)&amp;wolfman;    // 类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2: &quot;</span> &lt;&lt; ptr2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pwlf2: &quot;</span> &lt;&lt; pwlf2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;pman2: &quot; &lt;&lt; pman2 &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//_move = &amp;wolfman; // 多重继承  编译器不知道怎么转，尽量避免多重继承</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    WolfMan wolfman1;</span><br><span class="line">    wolfman<span class="number">1.</span>::Wolf::MonsterObject::MoveObject::x = <span class="number">2500</span>;</span><br><span class="line">    wolfman<span class="number">1.</span>::MoveObject::x = <span class="number">3500</span>;</span><br><span class="line">    MoveObject* _move1 = <span class="built_in">static_cast</span>&lt;MoveObject*&gt;(&amp;wolfman1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; _move1-&gt;x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强制类型转换都是有风险的！！！</p>
<p><strong>动态强制转换</strong></p>
<p><img src="https://bu.dusays.com/2024/12/08/67555d8e3fb89.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 33对象多态详解.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if (dynamic_cast&lt;MonsterObject*&gt;(this))</span></span><br><span class="line">        <span class="comment">// 不推荐写法，非常依赖派生类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*virtual*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPCObject</span> :<span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> :<span class="keyword">public</span> MonsterObject</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> :<span class="keyword">public</span> MonsterObject</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">boss</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WolfMan</span> : <span class="keyword">public</span> Man<span class="comment">//,public boss</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无论 向上转还是向下转，推荐无损转，使用指针或者引用来转</span></span><br><span class="line">    MonsterObject monster;</span><br><span class="line">    MoveObject* _move =(MoveObject*)&amp;monster;</span><br><span class="line">    MoveObject&amp; lMove = monster;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//_move = new MoveObject();</span></span><br><span class="line">    <span class="comment">//MonsterObject* _pmonsterA = dynamic_cast&lt;MonsterObject*&gt;(_move);</span></span><br><span class="line">    <span class="comment">//auto _pmonsterA = dynamic_cast&lt;MonsterObject*&gt;(_move);</span></span><br><span class="line">    <span class="comment">//MonsterObject和NPCObject之间没有继承关系，_move不能被转换为NPCObject*。</span></span><br><span class="line">    <span class="comment">//auto _pmonsterB = dynamic_cast&lt;NPCObject*&gt;(_move);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if (_pmonsterA != nullptr) _pmonsterA-&gt;MonsterMove();</span></span><br><span class="line">    <span class="comment">//if (_pmonsterB != nullptr) _pmonsterB-&gt;NPCMove();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接这样使用就可以了，避免过度使用 dynamic_cast</span></span><br><span class="line">    <span class="comment">//_move-&gt;Move();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不应该转换  没有空引用 </span></span><br><span class="line">    <span class="comment">//NPCObject&amp; lNPC = dynamic_cast&lt;NPCObject&amp;&gt;(monster);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有关系的类转换   跨类转换</span></span><br><span class="line">    WolfMan wlfman;</span><br><span class="line">    MoveObject* pMove = &amp;wlfman;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">dynamic_cast</span>&lt;WolfMan*&gt;(pMove);</span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">dynamic_cast</span>&lt;boss*&gt;(pMove);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1: &quot;</span> &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>抽象类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拥有纯虚函数的类称为抽象类，因为该类的函数没有实现，因此不能创建抽象类的实例</span></span><br><span class="line"><span class="comment">// 但是可以使用抽象类的指针和引用作为返回或参数！！</span></span><br><span class="line"><span class="comment">// 抽象类的构造函数因为不能实际使用，所以一般推荐把抽象类的构造函数定义为protected</span></span><br><span class="line"><span class="comment">// 抽象类的派生类如果没有定义纯虚函数，则该派生类依然是抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 这个虚函数没什么实际内容，就设计成纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Notice</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 发送通知</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Eat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个类里面都是纯虚函数，没有提供具体内容，这就是接口类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Animal</span>() &#123;&#125;  <span class="comment">// 抽象类的构造函数因为不能实际使用，所以一般推荐把抽象类的构造函数定义为protected</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里没有fly函数的，所以这个类也是抽象类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Animal GetAnm() &#123; &#125;  不能创建实体</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 拥有纯虚函数的类称为抽象类，因为该类的函数没有实现，因此不能创建抽象类的实例</span></span><br><span class="line">    <span class="comment">//Animal anm;</span></span><br><span class="line">    <span class="comment">//Animal* anm1 = new Cat(); // 指针可以，实体不行</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类的成员函数的指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的成员函数的函数指针.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里限定了类Wolf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(Wolf::* PGROUP)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Wolf</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pGroup = &amp;Wolf::Group0;</span><br><span class="line">        (<span class="keyword">this</span>-&gt;*pGroup)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Group0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;一阶段！！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Group1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;二阶段！！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Group2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;三阶段！！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PGROUP pGroup;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*COUNT)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PGROUP pFunction = &amp;Wolf::Group2;</span><br><span class="line">    Wolf* pWolf = <span class="keyword">new</span> <span class="built_in">Wolf</span>();</span><br><span class="line">    (pWolf-&gt;*pFunction)();  <span class="comment">// 成员函数的函数指针</span></span><br><span class="line"></span><br><span class="line">    COUNT _count = &amp;Wolf::Count;</span><br><span class="line">    _count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>; <span class="comment">// 类的前置声明</span></span><br><span class="line"><span class="comment">// 定义了一个新类型PGROUP，它是指向Wolf类的成员函数指针，指向的成员函数没有参数且返回类型为void</span></span><br><span class="line"><span class="comment">// PGROUP 是一个类型别名，用于指向Wolf类中没有参数且返回类型为void的成员函数。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(Wolf::* PGROUP)</span><span class="params">()</span></span>;  </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Wolf</span>()</span><br><span class="line">&#123;</span><br><span class="line">    pGroup = &amp;Wolf::Group0;  <span class="comment">// 构造函数中初始化pGroup</span></span><br><span class="line">    (<span class="keyword">this</span>-&gt;*pGroup)();        <span class="comment">// 调用pGroup指向的成员函数</span></span><br><span class="line">    PGROUP pGroup;  <span class="comment">// 成员函数指针，指向Wolf类的成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// COUNT是一个类型别名，用于定义指向没有参数且返回类型为void 普通函数的指针</span></span><br><span class="line"><span class="comment">// COUNT 是一个指向无参数无返回值函数的指针。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*COUNT)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PGROUP pFunction = &amp;Wolf::Group2;  <span class="comment">// 定义一个成员函数指针，指向Group2</span></span><br><span class="line">    Wolf* pWolf = <span class="keyword">new</span> <span class="built_in">Wolf</span>();  <span class="comment">// 创建一个Wolf对象（会调用构造函数）</span></span><br><span class="line">    (pWolf-&gt;*pFunction)();  <span class="comment">// 通过成员函数指针调用Group2</span></span><br><span class="line"></span><br><span class="line">    COUNT _count = &amp;Wolf::Count;  <span class="comment">// 定义一个普通函数指针，指向静态成员函数Count</span></span><br><span class="line">    _count();  <span class="comment">// 调用静态成员函数Count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员函数指针：指向类成员函数时，需要使用::*语法并制定类名。在调用的时候，必须通过类实例（this指针）来调用。</p>
<p>静态成员函数：静态成员函数不依赖于对象实例，可以像普通函数一样直接通过类名或函数指针调用。</p>
<p>成员函数与普通函数指针的不同：成员函数指针需要对象实例来调用，而普通函数指针则不需要。</p>
<p><strong>多态：虚函数的实现</strong></p>
<p>（面试可能问到）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConsoleApplication1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;劫持了！！！1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> HP;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AIM&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Die</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AIM_die&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> :<span class="keyword">public</span> AIM</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wolf&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Die</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WOLF-DIE&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Sound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;aoaoaoaoa~~~~&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AIM* wolf = <span class="keyword">new</span> <span class="built_in">Wolf</span>();</span><br><span class="line">    wolf-&gt;<span class="built_in">Die</span>(); <span class="comment">// 调用的是Wolf类中的函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出8   多了4个字节</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(AIM) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试下多出的四个字节是头部还是尾部</span></span><br><span class="line">    std::cout &lt;&lt; wolf &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;wolf-&gt;HP &lt;&lt; std::endl; <span class="comment">// 加在头部了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>* vtable = (<span class="type">unsigned</span>*)wolf;</span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="string">&quot;Vtable:  &quot;</span> &lt;&lt; vtable[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>* func = (<span class="type">unsigned</span>*)vtable[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="string">&quot;eat: &quot;</span> &lt;&lt; func[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="string">&quot;die: &quot;</span> &lt;&lt; func[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过修改虚函数表的数据可以实现劫持</span></span><br><span class="line">    DWORD old;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(func, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line">    func[<span class="number">0</span>] = (<span class="type">unsigned</span>)Hack;</span><br><span class="line">    func[<span class="number">1</span>] = (<span class="type">unsigned</span>)Hack;</span><br><span class="line">    wolf-&gt;<span class="built_in">Eat</span>();</span><br><span class="line">    <span class="comment">// 以上只是影响的Wolf类  </span></span><br><span class="line"></span><br><span class="line">    AIM* _aim = <span class="keyword">new</span> <span class="built_in">AIM</span>();</span><br><span class="line">    _aim-&gt;<span class="built_in">Eat</span>();</span><br><span class="line"></span><br><span class="line">    AIM* _aim1 = <span class="keyword">new</span> <span class="built_in">Wolf</span>();</span><br><span class="line">    _aim1-&gt;<span class="built_in">Eat</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只有通过指针访问函数才会调用虚函数表</span></span><br><span class="line">    Wolf wl;</span><br><span class="line">    wl.<span class="built_in">Sound</span>();  <span class="comment">// 这个不涉及指针，能够调用我们想要的函数</span></span><br><span class="line">    wl.<span class="built_in">Eat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://bu.dusays.com/2024/12/09/67568e837d723.png"></p>
<p> 虚表的性质</p>
<p>1️⃣ 同一个类的多个实例都指向同一个虚函数表</p>
<p>2️⃣ 通过修改虚函数表的数据可以实现劫持</p>
<p>3️⃣ 只有通过指针访问函数才会调用虚函数表</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus12跨语言编程</title>
    <url>/2024/12/11/Cplusplus12%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="C-调用汇编代码"><a href="#C-调用汇编代码" class="headerlink" title="C++ 调用汇编代码"></a>C++ 调用汇编代码</h3><p><strong>使用汇编代码的时机和意义</strong></p>
<p><img src="https://bu.dusays.com/2024/12/09/675697d600c3a.png"></p>
<p><strong>Microsoft c++ x86 内联汇编</strong></p>
<p><img src="https://bu.dusays.com/2024/12/09/675697d600c3a.png"></p>
<p><img src="https://bu.dusays.com/2024/12/09/67569ae9428a8.png"></p>
<p><img src="https://bu.dusays.com/2024/12/09/67569ae99537e.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要加分号   使用__asm来分割</span></span><br><span class="line">    __asm mov eax,a</span><br><span class="line">    __asm add eax,<span class="number">1</span></span><br><span class="line">    __asm mov a,eax</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a;  <span class="comment">// 251</span></span><br><span class="line">    <span class="comment">// 这样省略了很多__asm</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, a</span><br><span class="line">        add eax, <span class="number">1</span></span><br><span class="line">        mov a, eax</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a;  <span class="comment">// 252</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>__asm 中汇编使用规范</strong></p>
<p>_asm支持</p>
<p>Pentium 4 和 AMD Athlon 所有操作码</p>
<p>支持MMX指令集</p>
<p>可以利用_emit创建目标处理器支持的其他指令</p>
<p>如果_emit生成修改寄存器的值，编译器无法确定哪些寄存器受到影响，这个时候编译器容易做出错误的判断，程序可能产生不可预测的行为。</p>
<p>asm 与  段引用  __asm中必须通过寄存器来引用段  不能通过段名称来访问</p>
<p><img src="https://bu.dusays.com/2024/12/09/6756a0231248e.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">int</span> arySize;</span><br><span class="line"><span class="type">int</span> typeAry;</span><br><span class="line">_asm </span><br><span class="line">&#123;</span><br><span class="line">    mov count,LENGTH a</span><br><span class="line">    mov arySize,SIZE a</span><br><span class="line">    mov typeAry,TYPE a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;元素个数为： &quot;</span> &lt;&lt; count &lt;&lt; std::endl;  <span class="comment">// 1000</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;元素大小为： &quot;</span> &lt;&lt; arySize &lt;&lt; std::endl; <span class="comment">// 4000</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;元素大小为： &quot;</span> &lt;&lt; typeAry &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><strong>__asm的调试</strong></p>
<p>&#x2F;Zi 编译选项 可以使用源代码调试内联汇编程序，可以在C&#x2F;C++&#x2F;汇编代码上设置断点</p>
<p>把多条汇编语言放在同一行可能会妨碍调试</p>
<p><strong>__asm中 C&#x2F;C++使用规范</strong></p>
<p><img src="https://bu.dusays.com/2024/12/09/6756a02410305.png"></p>
<p><strong>__asm代码优化和寄存器的注意事项</strong></p>
<p>_fastcall 不建议包含_asm代码</p>
<p>esp、ebp跟栈有关系，不能随便改</p>
<p><strong>_declspec(naked)</strong></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus13常见的问题</title>
    <url>/2024/12/11/Cplusplus13%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="一、指针和引用的区别"><a href="#一、指针和引用的区别" class="headerlink" title="一、指针和引用的区别"></a><strong>一、指针和引用的区别</strong></h4><p><strong>①   定义和概念</strong></p>
<p>指针：指针是一个变量，其值为另一个变量的地址。指针本质上是存储内存地址的变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;  <span class="comment">// p 是指针，存储a的地址</span></span><br></pre></td></tr></table></figure>

<p>引用：引用是一个别名，它为已有的变量创建一个新的名字。引用初始化必须与某个变量绑定，并且一旦绑定之后不能再绑定到其他变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a  = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;  <span class="comment">// ref是 a的引用，相当于a的别名。</span></span><br></pre></td></tr></table></figure>

<p><strong>②   语法差异</strong> </p>
<p>指针语法：声明指针时候使用<code>*</code>符号、获取指针指向的变量的值需要使用解引用操作符<code>*</code>、需要显式地进行地址赋值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;  <span class="comment">// &amp;a 表示获取a的地址</span></span><br><span class="line"><span class="type">int</span> value = *p; <span class="comment">// *p表示解引用，得到a的值</span></span><br></pre></td></tr></table></figure>

<p>引用的语法：声明引用使用<code>&amp;</code>符号、引用像普通变量一样使用，不需要使用解引用操作符、引用必须在声明时进行初始化，并且无法更改引用的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;   <span class="comment">// ref 是 a 的引用</span></span><br><span class="line">ref = <span class="number">20</span>;		<span class="comment">// 改变a的值为20</span></span><br></pre></td></tr></table></figure>

<p><strong>③  是否允许为空值</strong></p>
<p>指针可以为<code>nullptr</code>，这意味着指针不指向任何有效的内存地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>引用必须始终绑定到一个有效的变量。引用不能是空的，因此在创建引用时必须确保它绑定到一个有效的变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;  <span class="comment">// ref必须引用一个已初始化的变量</span></span><br></pre></td></tr></table></figure>

<p><strong>④  是否可以重新绑定</strong></p>
<p>​	指针可以在程序执行过程中重新指向不同的变量。指针是动态可变的。</p>
<p>​	引用一旦绑定了某个变量，就不能再改变引用的对象，引用的绑定是固定的。</p>
<p><strong>⑤  内存分配</strong></p>
<p>指针是一个独立的变量，它需要占用内存存储地址。因此，指针本身需要内存空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;  <span class="comment">// p是指针，需要为p分配内存空间</span></span><br></pre></td></tr></table></figure>

<p>引用本身不占用额外的内存空间，它只是一个已经存在的变量的别名。引用的实现通常是通过指针来实现的，但从语法上它没有指针的表现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;  <span class="comment">// ref只是a的别名，不需要额外的内存</span></span><br></pre></td></tr></table></figure>

<p><strong>⑥  使用场景</strong></p>
<p>指针使用于需要动态管理内存、在函数间传递大量数据时，特别是在对象动态分配、链表、树等数据结构的实现</p>
<p>指针可以进行指针运算，例如加减操作，访问数组元素等。</p>
<p>引用 通常用于函数参数传递（尤其是传递大对象或者需要修改参数的情况下），引用使得函数调用更加简介并且避免了拷贝 的开销。</p>
<p>引用常用于返回对象的引用，或者作为输出参数的替代。</p>
<p><strong>⑦  安全性</strong></p>
<p>指针的安全性较差，容易发生空指针引用、悬挂指针等问题。例如，如果指针在使用后没有及时初始化为<code>nullptr</code>，可能会访问非法内存。</p>
<p>引用的安全性较高，因为引用始终必须绑定到一个有效对象，且不能为<code>nullptr</code> ， 这减少了访问无效内存的风险。</p>
<p><strong>⑧  是否可以被常量修饰</strong></p>
<p>指针可以被<code>const</code>修饰，指针本身、指针指向的内容都可以是常量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const 变量类型*  只能指向一个常量</span></span><br><span class="line"><span class="comment">// 特点，指针的指向可以修改，但是指针指向的值不可以修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">int</span> c&#123; <span class="number">300</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p&#123; &amp;a &#125;;</span><br><span class="line"><span class="comment">// *p = 500;  不可以修改值</span></span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">p = &amp;b;  <span class="comment">// 可以修改指向</span></span><br><span class="line">p = &amp;c;  <span class="comment">// 常量指针也可以指向非常量变量</span></span><br><span class="line"><span class="comment">// *p = 2000;  常量指针就是不让改</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//特点：指针的指向不可以改，指针指向的值可以改（内存中的数据可以更改）</span></span><br><span class="line"><span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p&#123; &amp;a &#125;;</span><br><span class="line"><span class="comment">//p = &amp;b;   不能修改指向</span></span><br><span class="line">*p = <span class="number">999</span>;  <span class="comment">//可以修改指针指向的内存空间</span></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl; <span class="comment">//  这时候a输出 999；</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const 变量类型* const</span></span><br><span class="line"><span class="comment">//特点：指针的指向和指针指向的值都不可以修改 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p&#123; &amp;a &#125;;</span><br><span class="line"><span class="comment">//p = &amp;b;  不能修改指向</span></span><br><span class="line"><span class="comment">//*p = 999;  不能修改内存空间里面的值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="comment">//int* pa&#123; &amp;a &#125;;   常量</span></span><br><span class="line"><span class="type">int</span>* pa&#123; (<span class="type">int</span>*)&amp;a &#125;;   <span class="comment">//通过转换是可以的</span></span><br><span class="line">*p = <span class="number">9500</span>;	<span class="comment">//这种操作是允许的，但是a的值不变</span></span><br><span class="line">std::cout &lt;&lt; *pa &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>引用可以是常量引用，表示不能修改引用的对象，但引用本身无法修改为指向其他对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = a;  <span class="comment">// ref是常量引用，不能修改a的值</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>指针</p>
<p>​	用于动态内存分配、数组、链表等数据结构。</p>
<p>​	在函数之间传递多个值，或者需要修改函数外部的对象时使用。</p>
<p>​	可以指向<code>nullptr</code>，适用于需要进行空指针检查的场景。</p>
<p>​	可以进行指针运算。</p>
<p>引用</p>
<p>​	用于函数参数传递，避免不必要的复制，尤其是在处理大型对象时。</p>
<p>​	用于返回对象的引用，以便函数外部能修改对象。</p>
<p>​	比指针更加简洁、直观。</p>
<p>​	不支持空引用，确保引用有效。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus06不同语言联合编程</title>
    <url>/2024/12/11/Cplusplus06%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>​                                                              <strong>此章节干货较少，笔记也比较混乱，理解为主</strong></p>
<p><strong>static 和 inline</strong></p>
<p>静态变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;    <span class="comment">// 初始化为0   生命周期跟全局变量一样（局部变量）  （不会放在栈上面）</span></span><br><span class="line">    std::cout &lt;&lt; count ++ &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态变量（无论是局部的还是全局的）通常被存储在 数据段（data segment）中，而不是栈或堆中。静态变量的内存分配在程序启动时就已完成，并且在整个程序运行期间都保持有效，直到程序退出。</span></span><br></pre></td></tr></table></figure>

<p>内联函数</p>
<p><strong>内联函数</strong>（Inline Function）是 C++ 中的一种函数优化技术，它的作用是让编译器将函数的代码直接嵌入到调用该函数的地方，而不是通过函数调用的机制进行跳转。这种优化有助于减少函数调用的开销（尤其是对于短小的函数），从而提高程序的执行效率。</p>
<p>递归函数不能用，本身就需要栈空间。</p>
<p>可以用一个inline声明一个内联函数   内联函数会建议编译器把这个函数处理成内联代码以提升性能</p>
<p>始终是建议，具体编译器是否采纳，由编译器决定。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span> + <span class="number">2</span>;   <span class="comment">// 加上inline之后，直接 把相应的代码放在这里了  不调用函数了   直接a + b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从编译器的角度理解定义和声明</strong></p>
<p>函数声明（也称为函数原型）是告诉编译器函数的名称、返回类型和参数类型的声明，但不包含函数体。它主要用于在调用函数之前告诉编译器函数的存在及其接口。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;  <span class="comment">//  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">ave</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数定义是函数的实际实现，包含了函数的返回类型、参数以及函数体。函数定义包括了函数的逻辑实现，并且会占用内存资源。</p>
<ul>
<li><strong>函数声明</strong>只提供函数的接口信息，不包含实现，通常用于让编译器在调用函数之前知道函数的存在。</li>
<li><strong>函数定义</strong>提供了函数的完整实现，包含了函数的所有细节。</li>
</ul>
<p><strong>变量和函数的不同（声明  定义）</strong></p>
<p><code>extern int x;</code>  &#x2F;&#x2F; 声明变量 x     声明，默认是extern</p>
<p><code>extern</code> 关键字用于声明变量而不定义它。这样可以在多个文件之间共享变量。例如，当你需要在多个源文件中使用同一个全局变量时，可以使用 <code>extern</code> 来声明该变量。</p>
<p>x86  32位windows操作系统下内存分配</p>
<p><strong>头文件和源文件</strong></p>
<p>头文件用于声明类、函数、变量、常量等信息，但不包含具体的实现</p>
<p>头文件只有在调用的时候才被编译，主要是用来写声明的，也可以写定义。</p>
<p>函数只要是在一个工程里就不能重复定义（重载除外）</p>
<p>情况 1️⃣ 静态函数，只在所在的cpp文件中有效，加上 <code>static</code> 关键字，那么不同的cpp文件中的静态函数都有各自的空间，如果不加，那么整个工程里面的相同函数名的函数都用的同一块空间。</p>
<p>情况 2️⃣ 内联函数  也是一样的</p>
<p>如果是变量的话，要用 <code>extern</code> 关键字，只声明不定义，那写在头文件里没问题。</p>
<p>静态变量也是在各自的源文件里有效。<code>static</code>关键字</p>
<p>重复调用的情况不会出现问题，原因是 <code>#pragma once</code>  但有的编译器不支持这个命令了 </p>
<p><strong>头文件保护机制</strong>（Include Guard）。头文件保护机制的目的是防止头文件被多次包含，避免重复定义和潜在的编译错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEMATH_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEMATH_</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>**<code>#ifndef _HEMATH_</code>**：<ul>
<li><code>#ifndef</code> 是 “if not defined” 的缩写，意思是“如果未定义”。</li>
<li>它检查是否已定义名为 <code>_HEMATH_</code> 的宏。如果没有定义，那么接下来的代码会被编译；如果已经定义，则跳过。</li>
<li>这个宏通常是头文件的唯一标识符，用来确保头文件只被包含一次。</li>
</ul>
</li>
<li>**<code>#define _HEMATH_</code>**：<ul>
<li><code>#define</code> 用于定义宏 <code>_HEMATH_</code>。一旦定义了这个宏，后续的 <code>#ifndef</code> 就会失败，避免重复包含该头文件。</li>
<li>宏 <code>_HEMATH_</code> 在第一次包含该头文件时定义，以后任何包含此头文件的地方都会跳过其中的内容。</li>
</ul>
</li>
<li>**<code>#endif</code>**：<ul>
<li>这是 <code>#ifndef</code> 的结束标志，表示条件编译的结束。它标志着条件保护代码块的结束。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：`hemath.h`</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEMATH_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEMATH_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在源文件中使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hemath.h&quot;</span> <span class="comment">// 第一次包含，宏 _HEMATH_ 没有定义，会进入条件编译区块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hemath.h&quot;</span> <span class="comment">// 第二次包含，宏 _HEMATH_ 已定义，直接跳过头文件内容</span></span></span><br></pre></td></tr></table></figure>

<p>这样，第二次 <code>#include</code> 时，头文件的内容就不会被重新包含，从而避了重复定义的问题。</p>
<ul>
<li>宏名字（<code>_HEMATH_</code>）可以自定义，但最好使用独特且具有全局唯一性的名字，通常使用项目名或文件名来避免与其他库的宏冲突。</li>
<li>另外，也可以考虑使用 <code>#pragma once</code> 来替代传统的 <code>#ifndef</code> 方式，这样做更简洁，并且现代编译器通常会优化它。</li>
</ul>
<p>C语言不支持函数重载，所以有多个源文件包含相同的函数，C语言把函数名加_  但是C++有函数重载不能这样处理，.c 文件和 .cpp 文件若有相同的函数，也不会出错，因为编译器处理之后 的名字不一样</p>
<p>1️⃣ 定义在C语言里面的函数，不能在C++中直接访问 （<strong>要使用extern关键字才行</strong>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">()</span></span>;  <span class="comment">// 加上这个就能在cpp文件里面运行c中的函数了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法1️⃣</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pve</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2️⃣   直接把头文件 用extern &quot;C&quot;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;e.h&quot;</span>  <span class="comment">// 头文件里面的全是C的风格</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种手段，C++可以调用C语言代码</p>
<p>2️⃣<strong>在C语言中调用C++的函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">xve</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 把C++ 中的函数定义成C风格即可</span></span><br></pre></td></tr></table></figure>

<p>为了让C语言文件知道C++中定义的函数，在C++的头文件中使用 <code>extern &quot;C&quot;</code> 来声明这些函数。这样，C语言和C++都可以包含这个头文件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.h (C++头文件)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;  <span class="comment">// 声明C++中的add函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>3️⃣ 在C语言代码中，使用extern “C” 声明该函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.c (C文件)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;  <span class="comment">// 声明C++中的add函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 调用C++中的函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>C 和 c++ 源文件混用的问题</strong></p>
<p>如果.c 文件 和 .cpp 文件重名（都叫a），那编译的时候，会有俩a.obj，一个文件下目录下有俩a.obj  那么就会出问题，尽量不要让C++和C文件重名</p>
<p><strong>创建自己的SDK</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;edoyun.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一  配好包含目录和库目录之后，写下面的指令即可</span></span><br><span class="line"><span class="comment">//#pragma comment(lib,&quot;edoyun.lib&quot;)</span></span><br><span class="line"><span class="comment">// 方法二  链接器-&gt;输入-&gt;附加依赖项</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; edoyun::<span class="built_in">GetVersion</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">ave</span>(<span class="number">100</span>,<span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://bu.dusays.com/2024/11/28/67480783670e4.png"></p>
<p><strong>函数调用约定</strong></p>
<p>函数调用约定是函数调用与被调用者之间的一种协议，这个协议主要规定了以下两个内容：</p>
<p>如何传递参数    如何恢复栈平衡</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ave</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __cdecl 参数入栈顺序 从右到左</span></span><br><span class="line"><span class="comment">// 堆栈平衡：谁调用谁平衡</span></span><br><span class="line"><span class="comment">// 正因为__cdecl这种堆栈平衡方式，能够支持不定量参数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __stdccall <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ave</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// __stdcall 参数入栈顺序  从右到左</span></span><br><span class="line"><span class="comment">// 堆栈平衡：函数自己恢复栈平衡</span></span><br><span class="line"><span class="comment">// Windows 编程中 WINAPI CALLBACK 都是 __stdcall 的宏</span></span><br><span class="line"><span class="comment">// 生成的函数名会加下划线，后面跟@和参数尺寸</span></span><br></pre></td></tr></table></figure>

<p><img src="https://bu.dusays.com/2024/11/28/674823c0b7270.png"></p>
<p><img src="https://bu.dusays.com/2024/11/28/674823ba10bfe.png"></p>
<p><strong>递归函数</strong></p>
<p><strong>递归函数</strong>是指在函数的定义中，调用了它自身的函数。递归的核心思想是将复杂的问题分解为更简单的同类问题。通过递归，问题可以被拆解成较小的子问题，直到达到最简单的基本情况（即递归的终止条件）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">ave</span>(x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">	string Id;</span><br><span class="line">	<span class="type">int</span> Exp;</span><br><span class="line">&#125;*PROLE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetDataCount</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> icount&#123;&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			icount++;</span><br><span class="line">			i += <span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> icount / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetStringData</span><span class="params">(PROLE prole, string&amp; strData, <span class="type">int</span> istart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	istart = strData.<span class="built_in">find</span>(<span class="string">&quot;id=&quot;</span>, istart);</span><br><span class="line">	<span class="keyword">if</span> (istart == std::string::npos) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> iend = strData.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>, istart + <span class="number">3</span>);</span><br><span class="line">	prole-&gt;Id = strData.<span class="built_in">substr</span>(istart + <span class="number">3</span>, iend - istart - <span class="number">3</span>);</span><br><span class="line">	istart = iend + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	istart = strData.<span class="built_in">find</span>(<span class="string">&quot;exp=&quot;</span>, istart);</span><br><span class="line">	iend = strData.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>, istart + <span class="number">4</span>);</span><br><span class="line">	prole-&gt;Exp = std::<span class="built_in">stoi</span>(strData.<span class="built_in">substr</span>(istart + <span class="number">4</span>, iend - istart - <span class="number">4</span>));</span><br><span class="line">	istart = iend + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">GetStringData</span>(++prole, strData, istart);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string strData = <span class="string">&quot;id=Tomy Clare;exp=9523;id=Sunny;exp=9523;id=DyBaby;exp=25301;id=Simple;exp=25301;id=Bkacs11;exp=2100;id=DumpX;exp=36520;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> icount&#123; <span class="built_in">GetDataCount</span>(strData) &#125;;</span><br><span class="line">	PROLE pRole = <span class="keyword">new</span> Role[icount];</span><br><span class="line">	<span class="built_in">GetStringData</span>(pRole, strData, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; icount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt; icount; y++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (pRole[y].Exp &gt; pRole[y - <span class="number">1</span>].Exp)</span><br><span class="line">			&#123;</span><br><span class="line">				Role tmp = pRole[y - <span class="number">1</span>];</span><br><span class="line">				pRole[y - <span class="number">1</span>] = pRole[y];</span><br><span class="line">				pRole[y] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; icount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; pRole[i].Id &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; pRole[i].Exp &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译器</strong></p>
<p><img src="https://bu.dusays.com/2024/11/28/674823b859eb4.png"></p>
<p>1️⃣ 未定义行为</p>
<p>C++标准未作规定的行为，称为未定义行为，未定义行为的结果是不确定的，具体在不同的编译器下会有不同的效果；</p>
<p><code>c=2*a++ + ++a*6;</code></p>
<p>这里先算<code>a++</code> 还是先算 <code>++ a</code> 就是一个未定义行为</p>
<p><code>int x = -25602;</code>   <code>x=x&gt;&gt;2;</code>  x的结果在不同编译器下是不确定的，这也属于未定义行为。</p>
<p>​								<strong>One Definition Rule</strong></p>
<p>ODR是一系列规则，而不是一个规则，程序中定义的每个对象都对应着自己的规则；</p>
<p>但是基本上来讲，任何变量、函数、类、枚举、模板，概念在每个转换单元中都只允许有一个定义；非inline的函数或者变量，在程序中，有且只有一个定义</p>
<p>仅在自己的转换单元有效：</p>
<p>1️⃣ <code>const</code>类型的变量 ：<strong>全局const变量</strong>，没有特别声明，只在当前转换单元内可见。<strong>静态const变量</strong>，在类或函数中的作用域内有效，不会暴露到其他地方。<strong>外部const变量</strong>，使用<code>extern</code>关键字使得变量拥有外部链接属性。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 只在当前源文件有效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> b;  <span class="comment">// 在其他文件中也可以引用，但变量定义只能在一个文件中</span></span><br></pre></td></tr></table></figure>

<p>2️⃣ <code>static</code> 类型的变量 ：<strong>全局static变量</strong>  仅在定义它的源文件内有效，不能被其他源文件访问。<strong>局部static变量</strong> 只在函数内有效，但它们的生命周期持续整个程序运行周期，只有在第一次调用时初始化，之后的调用将保留上一次修改的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> global_var = <span class="number">10</span>;  <span class="comment">// 只能在当前源文件有效</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> local_static = <span class="number">0</span>;  <span class="comment">// 只在该函数调用中有效，但其生命周期持续整个程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3️⃣ <code>inline</code> 变量：在当前转换单元内生效，但是可以跨多个转换单元共享。<code>inline</code>变量的作用类似于常量，允许在多个源文件中定义和使用，而不发生重复定义链接错误。</p>
<p><code>inline</code>变量通常用在头文件中定义常量或其他需要跨多个文件共享的变量。<code>inline</code>变量遵循一翻译单元一实例的规则，保证多个源文件中不会出现重复定义的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> a = <span class="number">1350</span>;  <span class="comment">// 内联变量，多个翻译单元可以共享这个变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">2000</span>;   <span class="comment">// 修改inline 变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：仅在当前翻译单元生效的：<code>static</code> 和 默认的 <code>const</code> 变量。  可以跨多个翻译单元共享：<code>inline</code> 变量。</p>
<p>名称的链接属性：</p>
<p>1️⃣ 内部链接属性：该名称仅在本转换单元中有效。</p>
<p>2️⃣ 外部链接属性：该名称在其他的转换单元中也有效。</p>
<p>3️⃣ 无链接属性： 该名称仅仅能够用于该名称的作用域内访问。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus09运算符重载</title>
    <url>/2024/12/11/Cplusplus09%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>运算符重载的主要目的是为了让目标代码更方便使用和维护，而不是提升开发效率，重载运算符未必能提升开发效率。</p>
<p>① 让类也支持原生的运算  比如 + -  * &#x2F; </p>
<p>② 提升对程序的控制权  比如重载new  delete new[]   delete[]</p>
<p>它允许你为自定义类型（如类或结构体）定义操作符的行为，使得这些操作符可以像内建类型一样工作。通过重载运算符，可以使自定义对象之间的运算更加直观和简洁。运算符重载是通过定义特殊的成员函数或友元函数来实现的</p>
<p><strong>初探运算符重载</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Person&amp; psa, Person&amp; psb);</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="built_in">operator</span>&lt;(Person&amp; psa, <span class="type">unsigned</span> <span class="type">short</span> _Age);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">unsigned</span> <span class="type">short</span> _Age) :Age&#123; _Age &#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获得私有变量</span></span><br><span class="line">	<span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">GetAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Age; &#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&gt;(Person&amp; person);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的成员函数来实现运算符重载</span></span><br><span class="line"><span class="type">bool</span> Person::<span class="keyword">operator</span>&gt;(Person &amp; person)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Age &gt; person.Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非类的成员函数实现运算符重载</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Person&amp; psa, Person&amp; psb)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> psa.<span class="built_in">GetAge</span>() &lt; psb.Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟数字比</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Person&amp; psa, <span class="type">unsigned</span> <span class="type">short</span> _Age)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> psa.Age &lt; _Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">Man</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">Woman</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 调用的是 Person::operator&gt;(Person &amp; person)</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="keyword">if</span> (Man&gt;Woman) std::cout &lt;&lt; <span class="string">&quot; 你找到富婆了！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用operator&lt;(Person&amp; psa, unsigned short _Age)</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="keyword">if</span> (Man &lt; <span class="number">10</span>) std::cout &lt;&lt; <span class="string">&quot; 你找到富婆了！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类的非成员函数实现运算符重载  声明为友元函数了</span></span><br><span class="line">	<span class="comment">// Man &lt; Woman &lt;=&gt; operator&lt;(Man,Woman)</span></span><br><span class="line">	<span class="keyword">if</span> (Man&lt;Woman) std::cout &lt;&lt; <span class="string">&quot; 你找到富婆了！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>！！！记住理解那些等价关系</p>
<p><strong>运算符重载的原则和时机</strong></p>
<p><img src="https://bu.dusays.com/2024/12/03/674e63385333d.png"></p>
<p>不能把加法重载为减法！！！</p>
<p><img src="https://bu.dusays.com/2024/12/03/674e65fd43456.png"></p>
<p><img src="https://bu.dusays.com/2024/12/03/674e65fd5013e.png"></p>
<p><img src="https://bu.dusays.com/2024/12/03/674e65fd5ca10.png"></p>
<p>传递值或者传递引用  建议传递引用  尤其是右值引用，不修改在前面加上<code>const</code> 就可以了</p>
<p><strong>重载赋值运算符</strong></p>
<p>默认赋值运算符重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Role x, y;</span></span><br><span class="line"><span class="comment">....</span></span><br><span class="line"><span class="comment">y = x;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    Role&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Role&amp; role);</span><br><span class="line">    &#123;</span><br><span class="line">        hp = role.hp;</span><br><span class="line">        mp = role.mp;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Role&amp; operator=(const Role&amp; role) = delete;   那么编译器就不再重载了</span></span><br><span class="line">    <span class="comment">// main.cpp中  y = x不再正确了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>实现赋值运算符的重载</strong></p>
<p>！！！operator&#x3D;只能用类的成员函数来实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    Role&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Role&amp; role);</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">Role&amp; Role::<span class="keyword">operator</span>=(<span class="type">const</span> Role&amp; role)</span><br><span class="line">&#123;</span><br><span class="line">        hp = role.hp;</span><br><span class="line">        mp = role.mp;</span><br><span class="line">    <span class="comment">// 而且返回值是空的时候void Role::operator=(const Role&amp; role)</span></span><br><span class="line">    <span class="comment">// 如果注释掉 return *this;  </span></span><br><span class="line">    <span class="comment">// 那么就不能 z = y = x;</span></span><br><span class="line">    <span class="comment">// z.operator=(y.operator=(x));   因为返回值为空，所以这个操作不能执行了</span></span><br><span class="line">    <span class="comment">// 返回值编程Role 类型也没问题，但是引用节省开销</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role x, y;</span><br><span class="line">    x.hp = <span class="number">100</span>;</span><br><span class="line">    y.mp = <span class="number">200</span>;</span><br><span class="line">    y = x;</span><br><span class="line">    <span class="comment">// z = y = x;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当类里面有指针的时候，往往不能采用默认运算符，必须重载（例子如下）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role x, y, z;</span><br><span class="line">    x.hp = <span class="number">100</span>;</span><br><span class="line">    y.mp = <span class="number">200</span>;</span><br><span class="line">    </span><br><span class="line">    z = y =x;</span><br><span class="line">    std::cout &lt;&lt; y.hp &lt;&lt; <span class="string">&quot;//////&quot;</span> &lt;&lt; y.mp;</span><br><span class="line">    <span class="type">char</span> strA[]&#123; <span class="string">&quot;aaaaabbbccccc&quot;</span> &#125;;</span><br><span class="line">    hstring str&#123; strA &#125;;</span><br><span class="line">    <span class="comment">// 如果strA的内存空间改变了，那么str没有值了，因为内存空间不属于str</span></span><br><span class="line">    strA[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; str.<span class="built_in">c_str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重载赋值运算符的代码如下</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hstring.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::GetStrLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (str[len] != <span class="string">&#x27;\0&#x27;</span>) &#123;  <span class="comment">// 遍历字符串直到遇到 &#x27;\0&#x27;</span></span><br><span class="line">		len++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝  函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::CopyStrs</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> len = <span class="built_in">GetStrLen</span>(source);</span><br><span class="line">	<span class="keyword">if</span> (len &gt; usmlen)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] cstr;  <span class="comment">// 释放之前分配的内存</span></span><br><span class="line">		cstr = <span class="keyword">new</span> <span class="type">char</span>[len];  <span class="comment">// 重新分配内存</span></span><br><span class="line">		usmlen = len; <span class="comment">// 修正内存长度 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(cstr, source, len);</span><br><span class="line">	cstr[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	uslen = len;  <span class="comment">// 字符串长度修正</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="comment">// 默认构造函数 </span></span><br><span class="line">hstring::<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line">	usmlen = <span class="number">0x32</span>;  <span class="comment">// 内存空间等于32字节</span></span><br><span class="line">	uslen = <span class="number">0</span>;</span><br><span class="line">	cstr = <span class="keyword">new</span> <span class="type">char</span>[usmlen];</span><br><span class="line">	cstr[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 初始化为空字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化hstring类对象的构造函数。</span></span><br><span class="line"><span class="comment">// 带参数的构造函数</span></span><br><span class="line"><span class="comment">// 可以接受一个或者多个参数，在创建对象时，通过这些参数来初始化对象的数据成员。这使得对象在创建之初就能被赋予特定的值。</span></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str) :<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">CopyStrs</span>(cstr, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数  使用一个已经存在的同类型对象初始化新创建的对象。它的参数是一个常量引用，指向同类型的对象。</span></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> hstring&amp; str):<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">CopyStrs</span>(cstr, str.cstr);</span><br><span class="line">&#125;</span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>=(<span class="type">const</span> hstring&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">CopyStrs</span>(cstr, str.cstr);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cstr != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] cstr;</span><br><span class="line">        cstr = <span class="literal">nullptr</span>;</span><br><span class="line">        usmlen = <span class="number">0</span>;</span><br><span class="line">        uslen = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tempValue = value;</span><br><span class="line">    <span class="type">bool</span> isNegative = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 计算数字的位数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断负号</span></span><br><span class="line">    <span class="keyword">if</span> (tempValue &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;  <span class="comment">// 负数的话  先把符号算进去</span></span><br><span class="line">        isNegative = <span class="literal">true</span>;</span><br><span class="line">        tempValue = -tempValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp = tempValue;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        temp = temp / <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (temp &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先判断是否为负数再判断是否为0  如果为0 数值位数就是1</span></span><br><span class="line">    <span class="keyword">if</span> (tempValue == <span class="number">0</span>) count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    uslen = count;       </span><br><span class="line">    usmlen = uslen + <span class="number">1</span>;       </span><br><span class="line">    cstr = <span class="keyword">new</span> <span class="type">char</span>[usmlen];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = usmlen - <span class="number">2</span>; <span class="comment">// usmlen-1是\0</span></span><br><span class="line">    cstr[usmlen - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isNegative)</span><br><span class="line">    &#123;</span><br><span class="line">        cstr[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里tempValue已经是个非负数了</span></span><br><span class="line">    <span class="keyword">while</span> (tempValue &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> charValue = (<span class="type">char</span>)(tempValue % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        cstr[index--] = charValue;</span><br><span class="line">        tempValue = tempValue / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>重载&lt;&lt; 和&gt;&gt;</strong></p>
<p><img src="https://bu.dusays.com/2024/12/07/67545d0215102.png"></p>
<p>·</p>
<p><strong>重载括号()</strong></p>
<p><img src="https://bu.dusays.com/2024/12/03/674eb16dbd58f.png"></p>
<p><strong>重载二元运算符</strong></p>
<p><img src="https://bu.dusays.com/2024/12/03/674eb16d9fbeb.png"></p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20241203204429786.png" alt="image-20241203204429786"></p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20241203210044300.png" alt="image-20241203210044300"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程01-基础知识</title>
    <url>/2025/01/09/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="一、套接字编程"><a href="#一、套接字编程" class="headerlink" title="一、套接字编程"></a>一、套接字编程</h3><p><strong>TCP服务端</strong></p>
<p>1️⃣ 创建套接字socket()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// PF_INET 指定协议族为 IPv4</span></span><br><span class="line"><span class="comment">// SOCK_STREAM：指定套接字类型为流套接字</span></span><br><span class="line"><span class="comment">// 0：指定协议类型，这里使用默认协议</span></span><br><span class="line"><span class="comment">// 如果socket函数成功创建套接字，会返回一个非负整数作为套接字描述符；如果失败，返回-1。</span></span><br></pre></td></tr></table></figure>

<p>2️⃣ 存储地址信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个struct sockaddr_in类型的变量addr，用于存储地址信息。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定地址族为 IPv4，AF代表 “Address Family”，AF_INET和前面的PF_INET相对应。</span></span><br><span class="line">addr.sin_family = AF_INET; </span><br><span class="line"></span><br><span class="line"><span class="comment">// INADDR_ANY，表示该套接字将绑定到服务器上的所有网络接口。</span></span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// htons函数将主机字节序的端口号 9527 转换为网络字节序，并存储在sin_port字段中。</span></span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br></pre></td></tr></table></figure>

<p>②分配套接字地址bind()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用bind函数将创建的套接字sock绑定到指定的地址和端口。</span></span><br><span class="line"><span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"><span class="comment">// 如果bind函数失败，返回-1。</span></span><br></pre></td></tr></table></figure>

<p>③等待连接请求状态listen()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">listen</span>(sockfd, <span class="number">5</span>);  <span class="comment">// 5 是请求队列的最大长度</span></span><br></pre></td></tr></table></figure>

<p>④允许连接accept()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> client_sock = <span class="built_in">accept</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_len);</span><br></pre></td></tr></table></figure>

<p>⑤数据交换read()&#x2F;write()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">read</span>(client_sock, buffer, <span class="built_in">sizeof</span>(buffer));  <span class="comment">// 接收客户端的数据</span></span><br><span class="line"><span class="built_in">write</span>(client_sock, <span class="string">&quot;Hello, Client!&quot;</span>, <span class="number">15</span>);   <span class="comment">// 发送数据到客户端</span></span><br></pre></td></tr></table></figure>

<p>⑥断开连接close()    关闭服务器套接字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(client_sock);</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br></pre></td></tr></table></figure>

<p><strong>客户端套接字编程流程</strong></p>
<p>①创建套接字socket()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>②设置服务器地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);  <span class="comment">// 服务器端的端口号</span></span><br><span class="line">server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.0.1&quot;</span>);  <span class="comment">// 服务器的 IP 地址</span></span><br></pre></td></tr></table></figure>

<p>③连接服务器（connect）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br></pre></td></tr></table></figure>

<p>④数据交换read()&#x2F;write()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(sockfd, <span class="string">&quot;Hello, Server!&quot;</span>, <span class="number">15</span>);  <span class="comment">// 向服务器发送数据</span></span><br><span class="line"><span class="built_in">read</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer));  <span class="comment">// 从服务器读取数据</span></span><br></pre></td></tr></table></figure>

<p>⑤断开连接close()    关闭服务器套接字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(sockfd);</span><br></pre></td></tr></table></figure>









<p><strong>客户端套接字地址信息在哪里</strong>？</p>
<p>网络数据交换必须分配IP和端口。  调用connect函数时，在操作系统内核 IP使用计算机的IP，端口随机</p>
<p>即 客户端IP地址和端口在调用connect函数时自动分配，无需调用标记的bind函数进行分配。</p>
<p>客户端在listen之后  close之前connect才有效</p>
<p><strong>迭代服务器</strong></p>
<p>普通服务器TCP的缺点：启动一次服务程序，只能给一个客户端服务。迭代服务器比较原始，它的原型可以描述成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    new_fd = 服务器 accept客户端的连接(new_fd = <span class="built_in">accept</span>(listenfd,xx,xx));</span><br><span class="line">    <span class="comment">//逻辑处理</span></span><br><span class="line">    <span class="comment">// 在这个new_fd上给客户端发送消息</span></span><br><span class="line">    <span class="comment">// 关闭new_fd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基本工作流程</strong></p>
<ol>
<li><strong>等待连接</strong> ：服务器会一直监听一个端口，等待客户端的连接。</li>
<li><strong>接受连接</strong> ：当客户端连接时，服务器会接受连接并建立一个新的套接字与客户端通信。</li>
<li><strong>处理请求</strong> ：服务器会处理客户端的请求，执行一些操作，或者提供一些服务。</li>
<li><strong>关闭连接</strong> ：处理完一个客户端的请求后，服务器关闭与该客户端的连接。</li>
<li><strong>继续等待</strong> ：服务器回到监听状态，等待下一个客户端的连接请求。</li>
</ol>
<p><strong>write函数和read函数</strong></p>
<p>①write函数   <code>ssize_t write(int fd, const void *buf, size_t count);</code></p>
<p><code>write</code>函数用于向文件描述符<code>fd</code>所指向的文件、套接字或其他I&#x2F;O设备中写入数据。</p>
<h3 id="TCP底层原理"><a href="#TCP底层原理" class="headerlink" title="TCP底层原理"></a>TCP底层原理</h3><p><code>write</code>函数调用后并非立即传输数据，read函数调用后也并非马上接收数据。<code>write</code>函数调用瞬间，数据将移至输出缓冲；<code>read</code>函数调用瞬间，从输入缓冲读取数据。</p>
<p>A：I&#x2F;O缓冲在每个套接字中单独存在。</p>
<p>B：I&#x2F;O缓冲在创建套接字时自动生成。</p>
<p>C：即使关闭套接字也会<strong>继续传递输出缓冲中遗留的数据</strong>。</p>
<p>D：关闭套接字将丢失输入缓冲中的数据。</p>
<p>“客户端输入缓冲50字节，而服务器端传输了100字节。”</p>
<p>填满输入缓冲前迅速调用read函数读取数据，就能腾出一部分空间，问题就解决了。</p>
<p>其实不会发生这类问题，因为TCP会控制数据流。TCP有滑动窗口协议。</p>
<p><strong>数据收发也是如此，因此TCP中不会因为缓冲溢出而丢失数据。</strong></p>
<p><strong>但是会因为缓冲而影响传输效率。</strong></p>
<h4 id="TCP内部原理"><a href="#TCP内部原理" class="headerlink" title="TCP内部原理"></a>TCP内部原理</h4><p><strong>TCP通信的三大步骤</strong></p>
<ol>
<li>三次握手建立连接；</li>
<li>开始通信，进行数据交换；</li>
<li>四次挥手断开连接；</li>
</ol>
<p>利用TCP三次握手进行攻击。</p>
<p>断开连接有可能卡在中间两次发数据包的地方。</p>
<h3 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h3><h4 id="UDP基本原理"><a href="#UDP基本原理" class="headerlink" title="UDP基本原理"></a>UDP基本原理</h4><p>4层TCP&#x2F;IP模型中，第二层传输层分为TCP和UDP。</p>
<p>只考虑可靠性，TCP比UDP更好。但UDP在结构上比TCP更简洁。UDP不会发送类似ACK的应答消息，也不会想SEQ那样给数据包分配序号。因此UDP的性能有时比TCP高出很多。</p>
<p>为了提供可靠的数据传输服务，TCP在不可靠的IP层进行流控制，而UDP就缺少这种流控制机制。</p>
<p>TCP的速度无法超过UDP，但在收发某些类型的数据时有可能接近UDP。例如，每次交换的数据量越大，TCP的传输速率越接近UDP的传输速率。</p>
<p><strong>TCP比UDP慢的原因</strong></p>
<p>① 收发数据前后进行的连接设置及清除过程。</p>
<p>② 收发数据过程中为保证可靠性而添加的流控制。</p>
<p><strong>UDP 服务端</strong></p>
<p>UDP   服务器&#x2F;客户端不像TCP那样在连接状态下交换数据，因此与TCP不同，无需经过连接过程。也就是说，不必调用TCP连接过程中调用的listen函数和accept函数。UDP中只有<strong>创建套接字的过程和数据交换的过程</strong>。</p>
<p>UDP的服务端和客户端都只需要一个套接字，而TCP中，套接字之间是一一对应的关系。若要向10个客户端提供服务，则除了守门的服务器套接字外，还需要10个服务器端套接字。</p>
<p>UDP套接字绑定本地的IP地址和端口号，这个套接字就可以接受来自任何主机发送到该端口的数据报。</p>
<p>创建好TCP套接字后，传输数据时无需再添加地址信息。但是UDP套接字不会保持连接状态（UDP套接字只有简单的邮筒功能），因此每次传输数据都要添加目标地址信息。这相当于寄信前在信件中填写地址。填写地址并传输数据时调用的UDP相关函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sock,<span class="type">void</span>*buff,<span class="type">size_t</span> nbytes,<span class="type">int</span> flags,<span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sock     用于传输数据的UDP套接字文件描述符。</span></span><br><span class="line"><span class="comment">buff     保存待传输数据的缓冲地址值。</span></span><br><span class="line"><span class="comment">nbytes   待传输的数据长度，以字节为单位。</span></span><br><span class="line"><span class="comment">flags    可选项参数，若没有则传递0。</span></span><br><span class="line"><span class="comment">to       存有目标地址信息的sockaddr结构体变量的地址值</span></span><br><span class="line"><span class="comment">addrlen  传递给参数to的地址值结构体变量长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">上述函数与之前的TCP输出函数最大的区别在于，此函数需要向它传递目标地址信息。接下来介绍接收UDP数据的函数。UDP数据的发送端并不固定，因此该函数定义为可接收发送端信息的形式，也就是将同时返回UDP数据包中的发送端信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sock,  <span class="type">void</span> *buff,<span class="type">size_t</span> nbytes,  <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">struct</span> sockaddr*from,   <span class="type">socklen_t</span>*addrlen)</span></span>;</span><br><span class="line"><span class="comment">// →成功时返回接收的字节数，失败时返回-1。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sock用于接收数据的UDP套接字文件描述符。</span></span><br><span class="line"><span class="comment">buff保存接收数据的缓存地址值</span></span><br><span class="line"><span class="comment">nbytes 可接收的最大字节数，故无法超过参数buf所指的缓冲大小。</span></span><br><span class="line"><span class="comment">flags可选项参数，若没有则传入0。</span></span><br><span class="line"><span class="comment">from存有发送端地址信息的sockaddr结构体变量的地址值。</span></span><br><span class="line"><span class="comment">addrlen 保存参数from的结构体变量长度的变量地址值。</span></span><br><span class="line"><span class="comment">编写UDP程序时最核心的部分就在于上述两个函数，这也说明二者在UDP数据传输中的地位。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>UDP相关的函数</p>
<p>DDos攻击大多利用UDP</p>
<p><strong>发生地址分配错误</strong>（重点）</p>
<p>客户端是connect，所以不会出现bind  failed，因为有几万个端口可以用，所以connect失败很难</p>
<p><strong>I&#x2F;O缓冲区大小</strong></p>
<p><strong>TCP_NODELAY</strong></p>
<p>监控键盘的输入</p>
<h3 id="Linux系统编程：进程"><a href="#Linux系统编程：进程" class="headerlink" title="Linux系统编程：进程"></a>Linux系统编程：进程</h3><h4 id="并发服务器的实现方法"><a href="#并发服务器的实现方法" class="headerlink" title="并发服务器的实现方法"></a>并发服务器的实现方法</h4><p>使其同时相所有发起请求的客户端提供服务，以提高平均满意度。</p>
<p>而且，<strong>网络程序中数据通信时间比CPU运算时间占比更大，因此，向多个客户端提供服务是一种有效利用CPU的方式。</strong></p>
<ol>
<li>多进程服务器：通过创建多个进程提供服务。</li>
<li>多路复用服务器：通过捆绑并统一管理I&#x2F;O对象提供服务。</li>
<li>多线程服务器：通过生成与客户端等量的线程提供服务。</li>
</ol>
<p><strong>进程</strong>：占用内存空间正在运行的程序 就是进程</p>
<p>从操作系统的角度来看，<strong>进程是程序流的基本单位</strong>，若创建多个进程，则操作系统将同时运行。有时候一个程序运行过程中也会产生多个进程。</p>
]]></content>
      <categories>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程04-线程与多线程</title>
    <url>/2025/01/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B04-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>线程是在进程中产生的一个执行单元，是CPU调度和分配的最小单元，其在同一个进程中与其他线程并行运行，他们可以共享进程内的资源，比如内存、地址空间、打开的文件等等。</p>
<p>   <strong>线程</strong>是CPU调度和分派的基本单位，</p>
<p>   <strong>进程</strong>是分配资源的基本单位</p>
<p><img src="https://bu.dusays.com/2025/01/13/67841d43278bb.png"></p>
<p>进程：正在运行的程序（狭义）</p>
<p>是处于执行期的程序以及它所管理的资源（如打开的文件、挂起的信号、进程状态、地址空间等等）的总称，从操作系统核心角度来说，进程是操作系统调度除CPU时间片外进行的资源分配和保护的基本单位，它有一个独立的虚拟地址空间，用来容纳进程映像(如与进程关联的程序与数据)，并以进程为单位对各种资源实施保护，如受保护地访问处理器、文件、外部设备及其他进程(进程间通信) </p>
<h4 id="为什么使用多线程？"><a href="#为什么使用多线程？" class="headerlink" title="为什么使用多线程？"></a>为什么使用多线程？</h4><p>1️⃣ <strong>避免阻塞</strong>：单个进程只有一个主线程，当主线程阻塞的时候，整个进程也就阻塞了，无法再去做其它的一些功能了。</p>
<p>2️⃣ <strong>避免CPU空转</strong>：应用程序经常会涉及到 <code>RPC</code>，数据库访问，磁盘IO等操作，这些操作的速度比CPU慢很多，而在等待这些响应时，CPU却不能去处理新的请求，导致这种单线程的应用程序性能很差。</p>
<p>3️⃣ <strong>提升效率</strong>：一个进程要独立拥有 4 GB的虚拟地址空间，而多个线程可以共享同一地址空间，线程的切换比进程的切换要快得多。</p>
<p><img src="https://bu.dusays.com/2025/01/13/67841d4328da3.png"></p>
<h3 id="线程的创建与运行"><a href="#线程的创建与运行" class="headerlink" title="线程的创建与运行"></a>线程的创建与运行</h3><p><strong><code>pthread_create</code>函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程的创建</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">pthread_t</span>*restrict thread, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">pthread_attr_t</span> * restrict attr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> *(* start_routine)(<span class="type">void</span> *),</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span>*restrict arg </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line">thread</span><br><span class="line"><span class="comment">// 保存新创建线程ID的变量地址值。线程与进程相同，也需要用于区分不同线程的ID。</span></span><br><span class="line">attr</span><br><span class="line"><span class="comment">// 用于传递线程属性的参数，传递NULL时，创建默认属性的线程。</span></span><br><span class="line"></span><br><span class="line">start_routine</span><br><span class="line"><span class="comment">// 相当于线程main函数的、在单独执行流中执行的函数地址值（函数指针）。</span></span><br><span class="line"></span><br><span class="line">arg</span><br><span class="line"><span class="comment">// 通过第三个参数传递调用函数时包含传递参数信息的变量地址值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>pthread_join</code>函数<br>调用<code>pthread_join</code>函数的进程（或线程）将进入等待状态，直到第一个参数为ID的线程终止为止。而且可以得到线程的main函数返回值，所以该函数比较有用。下面通过示例了解该函数的功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> ** status)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadEntry</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;i am from thread&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s thread begin: %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, arg);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span>*)msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession94</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> tid;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* pInfo = <span class="string">&quot;hello world&quot;</span>; <span class="comment">// 全局的</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, threadEntry,(<span class="type">void</span>*)pInfo);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">void</span>* result = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">pthread_join</span>(tid, &amp;result);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s from thread: %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要使用局部变量</p>
<h3 id="线程同步：互斥量"><a href="#线程同步：互斥量" class="headerlink" title="线程同步：互斥量"></a>线程同步：互斥量</h3><p>两个线程直接访问一个全局变量并进行对应的运算，结果是不确定的</p>
<p><strong>线程同步</strong>用于解决线程访问顺序引发的问题。需要同步的情况可以从如下两方面考虑。</p>
<p><strong>1****、同时访问同一内存空间时发生的情况。</strong></p>
<p><strong>2****、需要指定访问同一内存空间的线程执行顺序的情况。</strong></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_inc</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实时性高，但抢占差</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">		num++;</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">10000</span>) <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s num is: %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_dec</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实时性差，但抢占高</span></span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		num--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//互斥量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession95</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">pthread_t</span> thread_id[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">pthread_create</span>(thread_id + i, <span class="literal">NULL</span>, thread_inc, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">pthread_create</span>(thread_id + i, <span class="literal">NULL</span>, thread_dec, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pthread_join</span>(thread_id[i], <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s num is: %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, num);</span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程同步：信号量"><a href="#线程同步：信号量" class="headerlink" title="线程同步：信号量"></a>线程同步：信号量</h3><p>信号量与互斥量极为相似，在互斥量的基础上很容易理解信号量</p>
<p>初始值为 1 的信号量，可以用作互斥锁（把信号值始终控制为1）</p>
<p>信号量创建及销毁方法如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数一  创建信号量时传递保存信号量的变量地址值，销毁时传递需要销毁的信号量变量地址值。</span></span><br><span class="line"><span class="comment">// 参数二  决定几个线程</span></span><br><span class="line"><span class="comment">// 参数三  指定初始值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span>*sem)</span></span>;  <span class="comment">// V 操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> * sem)</span></span>;  <span class="comment">// P操作</span></span><br></pre></td></tr></table></figure>

<h3 id="线程的销毁"><a href="#线程的销毁" class="headerlink" title="线程的销毁"></a>线程的销毁</h3><p><strong>销毁线程的2种方法</strong></p>
<p>Linux线程并不是在首次调用的线程main函数返回时自动销毁，所以用如下2种方法之一加以明确。否则由线程创建的内存空间将一直存在。</p>
<p>1、调用pthread_join函数。</p>
<p>2、调用pthread_detach函数。</p>
<p>之前调用过pthread_join函数。调用该函数时，不仅会等待线程终止，还会引导线程销毁。但该函数的问题是，线程终止前，调用该函数的线程将进入阻塞状态。因此，通常通过如下函数调用引导线程销毁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用 <strong>pthread_detach</strong>函数不会引起线程终止或进入阻塞状态，可以通过该函数引导销毁线程创建的内存空间。</p>
<p><code>pthread_detach(pthread_self());</code> </p>
<p><code>pthread_exit(0) ;</code></p>
<p>调用以上线程函数来进行自动销毁无需外部的操作</p>
<h3 id="多线程并发服务器的实现"><a href="#多线程并发服务器的实现" class="headerlink" title="多线程并发服务器的实现"></a>多线程并发服务器的实现</h3><p><strong>聊天室项目：网络编程 + 多线程 + 线程同步实现的 聊天服务器和客户端</strong></p>
<p>以前进程是，每有客户端连接，fork一次，现在是开一个线程来和客户端进行沟通，主的在等待</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> clnt_socks[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> clnt_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向所有已连接的客户端发送消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_msg</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">ssize_t</span> str_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;mutex1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clnt_cnt; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (clnt_socks[i] &gt;= <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">write</span>(clnt_socks[i], msg, str_len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">handle_clnt</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line">	<span class="type">int</span> clnt_sock = *(<span class="type">int</span>*)arg;</span><br><span class="line">	<span class="type">char</span> msg[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">ssize_t</span> str_len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((str_len = <span class="built_in">read</span>(clnt_sock, msg, <span class="built_in">sizeof</span>(msg))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//<span class="doctag">TODO:</span>过滤敏感词</span></span><br><span class="line">		<span class="built_in">send_msg</span>(msg, str_len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;mutex1);</span><br><span class="line">	<span class="comment">//for (int i = 0; i &lt; clnt_cnt; i++) &#123;//TDDO:优化逻辑</span></span><br><span class="line">	<span class="comment">//	if (clnt_sock == clnt_socks[i]) &#123;</span></span><br><span class="line">	<span class="comment">//		clnt_socks[i] = -1;</span></span><br><span class="line">	<span class="comment">//		break;</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	*(<span class="type">int</span>*)arg = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex1);</span><br><span class="line">	<span class="built_in">close</span>(clnt_sock);</span><br><span class="line">	<span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">server98</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, clnt_adr;</span><br><span class="line">	<span class="type">socklen_t</span> clnt_adr_sz = <span class="built_in">sizeof</span>(clnt_adr);</span><br><span class="line">	serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">	serv_adr.sin_family = AF_INET;</span><br><span class="line">	serv_adr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">	serv_adr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个互斥锁，保护共享资源。NULL表示默认属性</span></span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mutex1, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bind error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;listen error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;<span class="comment">//while(1)等价</span></span><br><span class="line">        <span class="comment">//accept函数会阻塞，直到有客户端连接。如果成功，返回一个新的套接字描述符clnt_sock</span></span><br><span class="line">		clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">		<span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;accept error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 锁定互斥锁mutex1，以防止多个线程同时访问共享资源clnt_socks和clnt_cnt。</span></span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mutex1);</span><br><span class="line">		clnt_socks[clnt_cnt++] = clnt_sock;</span><br><span class="line">        <span class="comment">// 解锁互斥锁mutex1。</span></span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex1);</span><br><span class="line">		<span class="type">pthread_t</span> thread;</span><br><span class="line">        <span class="comment">// 创建一个新的线程，执行handle_clnt函数</span></span><br><span class="line"><span class="comment">// 并将新接受的客户端套接字描述符的地址作为参数传递给handle_clnt函数。NULL表示使用默认的线程属性。</span></span><br><span class="line">		<span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, handle_clnt, &amp;clnt_socks[clnt_cnt - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="comment">// 销毁互斥锁mutex1。</span></span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mutex1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">sem_t</span> semid;</span><br><span class="line"><span class="type">char</span> name[<span class="number">64</span>] = <span class="string">&quot;[DEFAULT]&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">client_send_msg</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="comment">// 从传入的参数中获取客户端套接字描述符</span></span><br><span class="line">	<span class="type">int</span> sock = *(<span class="type">int</span>*)arg;</span><br><span class="line">	<span class="type">char</span> msg[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">		<span class="built_in">fgets</span>(msg, <span class="built_in">sizeof</span>(msg), stdin);</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">strcmp</span>(msg, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(msg, <span class="string">&quot;Q\n&quot;</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(msg), <span class="string">&quot;%s %s&quot;</span>, name, msg);</span><br><span class="line">		<span class="built_in">write</span>(sock, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sem_post</span>(&amp;semid);  <span class="comment">// V操作</span></span><br><span class="line">	<span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">client_recv_msg</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line">	<span class="type">int</span> sock = *(<span class="type">int</span>*)arg;</span><br><span class="line">	<span class="type">char</span> msg[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 套接字sock读取数据，存储到msg中，str_len为读取的字节数。</span></span><br><span class="line">		<span class="type">ssize_t</span> str_len = <span class="built_in">read</span>(sock, msg, <span class="built_in">sizeof</span>(msg));</span><br><span class="line">		<span class="keyword">if</span> (str_len &lt;= <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">fputs</span>(msg, stdout);</span><br><span class="line">		<span class="built_in">memset</span>(msg, <span class="number">0</span>, str_len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sem_post</span>(&amp;semid);  <span class="comment">// V 操作</span></span><br><span class="line">	<span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>); <span class="comment">// 线程结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client98</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">	serv_addr.sin_family = AF_INET;</span><br><span class="line">	serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">	serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;input your name:&quot;</span>, stdout);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connect error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 定义两个线程标识符thsend和threcv，分别用于发送和接收消息的线程。</span></span><br><span class="line">	<span class="type">pthread_t</span> thsend, threcv;</span><br><span class="line">    <span class="comment">// 初始化信号量semid。0表示信号量是进程内共享的，-1是信号量的初始值。</span></span><br><span class="line">	<span class="built_in">sem_init</span>(&amp;semid, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给线程绑定主函数</span></span><br><span class="line">    <span class="comment">// (void*)&amp;sock  参数</span></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;thsend, <span class="literal">NULL</span>, client_send_msg, (<span class="type">void</span>*)&amp;sock);</span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;threcv, <span class="literal">NULL</span>, client_recv_msg, (<span class="type">void</span>*)&amp;sock);</span><br><span class="line">	<span class="built_in">sem_wait</span>(&amp;semid);  <span class="comment">// P操作</span></span><br><span class="line">	<span class="built_in">close</span>(sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession98</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;s&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">server98</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">client98</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程03-进程通信</title>
    <url>/2025/01/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B03-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p><strong>进程通信：为了方便进程交换信息，在内核提供缓冲区进行数据交换的机制。</strong></p>
<p>交换数据时基于开发 &#x2F; 权限 的</p>
<p>缓冲区两边像是有俩齿轮一样，如果是比作商店的话，一边是放进去东西，一边是拿出去东西，形成了消息处理的流水线。</p>
<h4 id="进程间通信：管道"><a href="#进程间通信：管道" class="headerlink" title="进程间通信：管道"></a>进程间通信：管道</h4><p><strong>单管道</strong></p>
<p><img src="https://bu.dusays.com/2025/01/12/6783c9daa4ad9.png"></p>
<p>为了完成进程间通信，需要创建管道。管道并非属于进程的资源，而是和套接字一样，属于操作系统（也就不是fork函数的复制对象）。所以，两个进程通过操作系统提供的内存空间进行通信。</p>
<p>父进程调用该函数时将<strong>创建管道</strong>，同时获取对应于出入口的文件描述符号</p>
<p><code>Filedes[0]</code> 通过管道接收数据时使用的文件描述符，即管道出口。</p>
<p><code>Fledes[1]</code> 通过管道传输数据时使用的文件描述符，即管道入口。</p>
<p>父进程创建子进程的时候，自己的资源镜像复制到子进程里面，所以父进程创建了管道子进程是有这个信息的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">singlePipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 两个文件描述符</span></span><br><span class="line">	<span class="type">int</span> fds[<span class="number">2</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">128</span>] = <span class="string">&quot;send by sub process!!!\n&quot;</span>;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="built_in">pipe</span>(fds);</span><br><span class="line">	<span class="type">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">write</span>(fds[<span class="number">1</span>], str, <span class="built_in">sizeof</span>(str));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">read</span>(fds[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d): %s server: %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, buf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双管道</strong></p>
<p>1个管道无法完成双向通信任务，有时候需要创建2个管道，各自负责不同的数据流动即可。</p>
<p><img src="https://bu.dusays.com/2025/01/12/6783d16c0a2b6.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doublePipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 两个方向各有俩文件描述符</span></span><br><span class="line">	<span class="type">int</span> s2c[<span class="number">2</span>], c2s[<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">pipe</span>(s2c);</span><br><span class="line">	<span class="built_in">pipe</span>(c2s);</span><br><span class="line">	<span class="type">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="built_in">write</span>(c2s[<span class="number">1</span>], <span class="string">&quot;hello,i am subprocess!\n&quot;</span>, <span class="number">23</span>);</span><br><span class="line">		<span class="built_in">read</span>(s2c[<span class="number">0</span>], buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d): %s server: %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, buffer);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">read</span>(c2s[<span class="number">0</span>], buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">		<span class="built_in">write</span>(s2c[<span class="number">1</span>], <span class="string">&quot;hello,i am mainprocess\n&quot;</span>, <span class="number">23</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d): %s server: %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, buffer);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s(%d): %s server: %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">getpid</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进程间通信：FIFO"><a href="#进程间通信：FIFO" class="headerlink" title="进程间通信：FIFO"></a>进程间通信：FIFO</h4><p>​	对比pipe管道，他已经可以完成在两个进程之间通信的任务，不过它似乎完成的不够好，也可以说是不够彻底。它只能在两个有<strong>亲戚关系</strong>的进程之间进行通信，这就大大限制了pipe管道的应用范围。</p>
<p>​	<code>fifo</code>管道的本质是操作系统中的命名文件，当然Linux的理念就是万物皆文件，它在操作系统中以命名文件的形式存在，我们可以在操作系统中看见<code>fifo</code>管道，在你有权限的情况下，甚至可以读写他们。</p>
<p>内核会针对<code>fifo</code>文件开辟一个缓冲区，操作FIFO文件，可以操作缓冲区，实现进程通信。一旦使用<code>mkfifo</code>创建了一个FIFO，就可以使用open打开它，常见的文件IO函数都可以用于<code>FIFO</code>。如：<code>close</code>、<code>read</code>、<code>write</code>、<code>unlink</code>等 .</p>
<p>这样的话  一个进程对应一个管道，大大减少了管道的数量。</p>
<p><strong>打开FIFO文件的时候，read端会阻塞等待write端打开open，write端同理，也会阻塞等待另外一端打开。</strong></p>
<h4 id="进程间通信：共享内存"><a href="#进程间通信：共享内存" class="headerlink" title="进程间通信：共享内存"></a>进程间通信：共享内存</h4><p>共享内存允许不同进程之间<strong>共享同一段逻辑内存</strong>，对于这段内存，它们都能访问，或者修改它，没有任何限制。所以它是<strong>进程间传递大量数据</strong>的一种非常有效的方式。“共享内存允许不同进程之间共享同一段逻辑内存”，这里是逻辑内存。也就是说共享内存的进程访问的可以不是同一段物理内存，这个没有明确的规定，但是大多数的系统实现都将进程之间的共享内存安排为同一段物理内存。</p>
<p><strong>使用共享内存的步骤通常是：</strong></p>
<p>1）创建或获取一段共享内存；</p>
<p>2）将上一步创建的共享内存映射到该进程的地址空间；</p>
<p>3）访问共享内存；</p>
<p>4）将共享内存从当前的进程地址空间分离；</p>
<p>5）删除这段共享内存；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession90</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// . 表明当前的路径 </span></span><br><span class="line">		<span class="comment">//  ftok(&quot;.&quot;,1)文件目录不一样   后面的数字也不一样 </span></span><br><span class="line">		<span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>,<span class="number">1</span>), <span class="built_in">sizeof</span>(STUDENT), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">		<span class="keyword">if</span> (shm_id == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s(%d): %s create share memeory failed!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 使用函数shmat()来映射共享内存</span></span><br><span class="line">		PSTUDENT pStu = (PSTUDENT)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		pStu-&gt;id = <span class="number">666666</span>;</span><br><span class="line">		<span class="built_in">strcpy</span>(pStu-&gt;name, <span class="string">&quot;买买提&quot;</span>);</span><br><span class="line">		pStu-&gt;age = <span class="number">18</span>;</span><br><span class="line">		pStu-&gt;sex = <span class="literal">true</span>;</span><br><span class="line">		pStu-&gt;sig = <span class="number">99</span>;</span><br><span class="line">		<span class="comment">// 两边需要同步   不同步直接删除映射就拿不到数据</span></span><br><span class="line">		<span class="keyword">while</span> (pStu-&gt;sig == <span class="number">99</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 删除映射</span></span><br><span class="line">		<span class="built_in">shmdt</span>(pStu);</span><br><span class="line">		<span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">// 子进程</span></span><br><span class="line">		<span class="built_in">usleep</span>(<span class="number">500000</span>); <span class="comment">// 等待父进程写入</span></span><br><span class="line">		<span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>), <span class="built_in">sizeof</span>(STUDENT), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">		<span class="keyword">if</span> (shm_id == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s(%d): %s create share memeory failed!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 使用函数shmat()来映射共享内存</span></span><br><span class="line">		PSTUDENT pStu = (PSTUDENT)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> (pStu-&gt;sig != <span class="number">99</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d, %s,%d,%s\n&quot;</span>, pStu-&gt;id, pStu-&gt;name, pStu-&gt;age, pStu-&gt;sex ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>);</span><br><span class="line">		pStu-&gt;sig = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">shmdt</span>(pStu);</span><br><span class="line">		<span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="进程间通信：信号量"><a href="#进程间通信：信号量" class="headerlink" title="进程间通信：信号量"></a>进程间通信：信号量</h4><ul>
<li>假设没有信号量，父子进程可能会同时访问共享内存，导致数据不一致。例如，父进程可能正在写入数据，而子进程同时尝试读取尚未完全写入的数据。通过信号量的 P 操作（<code>semop</code>函数，<code>sem_op</code>为 - 1）和 V 操作（<code>semop</code>函数，<code>sem_op</code>为 1），可以确保在某一时刻只有一个进程能够访问共享内存中的关键区域。比如，子进程在读取共享内存中的学生信息之前，先对信号量进行 P 操作，等待父进程完成写入并执行 V 操作释放资源后，子进程才能读取，从而避免了数据竞争和不一致性。</li>
</ul>
<p>原来共享内存有很严重的时间差，降低了效率。</p>
<p>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession91</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">//父进程</span></span><br><span class="line">		<span class="comment">// 使用ftok函数生成一个唯一的键值key，用于创建信号量。</span></span><br><span class="line">		<span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// semget函数创建一个信号量集，包含 2 个信号量，权限为0666。</span></span><br><span class="line">		<span class="type">int</span> sem_id = <span class="built_in">semget</span>(key, <span class="number">2</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//使用semctl函数初始化两个信号量的值为 0。</span></span><br><span class="line">		<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, SETVAL, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//调用shmget函数创建一个共享内存段，大小为sizeof(STUDENT)，权限为0666。</span></span><br><span class="line">		<span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>), <span class="built_in">sizeof</span>(STUDENT), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">		<span class="keyword">if</span> (shm_id == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s create share memeory failed!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将共享内存段附加到进程的地址空间，返回一个指向共享内存的指针pStu。</span></span><br><span class="line">		<span class="comment">//映射</span></span><br><span class="line">		PSTUDENT pStu = (PSTUDENT)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		pStu-&gt;id = <span class="number">666666</span>;</span><br><span class="line">		<span class="built_in">strcpy</span>(pStu-&gt;name, <span class="string">&quot;abcdefghijklmn&quot;</span>);</span><br><span class="line">		pStu-&gt;age = <span class="number">18</span>;</span><br><span class="line">		pStu-&gt;sex = <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">//信号量</span></span><br><span class="line">		sembuf sop = &#123;</span><br><span class="line">			.sem_num = <span class="number">0</span>,</span><br><span class="line">			.sem_op = <span class="number">1</span>  <span class="comment">// 为正数，semop就是V操作</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取信号量的值，</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, GETVAL));</span><br><span class="line">		<span class="built_in">semop</span>(sem_id, &amp;sop, <span class="number">1</span>);<span class="comment">//V操作</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, GETVAL));</span><br><span class="line">		sop.sem_num = <span class="number">1</span>;</span><br><span class="line">		sop.sem_op = <span class="number">-1</span>;  <span class="comment">// 为负数，semop为P操作</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, GETVAL));</span><br><span class="line">		<span class="built_in">semop</span>(sem_id, &amp;sop, <span class="number">1</span>);<span class="comment">//P操作</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, GETVAL));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将共享内存段从进程的地址空间分离</span></span><br><span class="line">		<span class="built_in">shmdt</span>(pStu);</span><br><span class="line">		<span class="comment">//删除共享内存段。</span></span><br><span class="line">		<span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">//删除信号量</span></span><br><span class="line">		<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, IPC_RMID);</span><br><span class="line">		<span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, IPC_RMID);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="comment">//子进程</span></span><br><span class="line">		<span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">2</span>);</span><br><span class="line">		<span class="comment">//semget和shmget函数获取已存在的信号量和共享内存段。</span></span><br><span class="line">		<span class="type">int</span> sem_id = <span class="built_in">semget</span>(key, <span class="number">2</span>, IPC_CREAT);</span><br><span class="line">		<span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>), <span class="built_in">sizeof</span>(STUDENT), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">		<span class="keyword">if</span> (shm_id == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s create share memeory failed!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sembuf sop = &#123;</span><br><span class="line">			.sem_num = <span class="number">0</span>,</span><br><span class="line">			.sem_op = <span class="number">-1</span><span class="comment">//P操作</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, GETVAL));</span><br><span class="line">		<span class="built_in">semop</span>(sem_id, &amp;sop, <span class="number">1</span>);<span class="comment">//P操作</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, GETVAL));</span><br><span class="line">		PSTUDENT pStu = (PSTUDENT)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//信号量</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d ,%s,%d,%s\n&quot;</span>, pStu-&gt;id, pStu-&gt;name, pStu-&gt;age, pStu-&gt;sex ? <span class="string">&quot;male&quot;</span> : <span class="string">&quot;female&quot;</span>);</span><br><span class="line">		sop.sem_num = <span class="number">1</span>;</span><br><span class="line">		sop.sem_op = <span class="number">1</span>;<span class="comment">//V操作</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, GETVAL));</span><br><span class="line">		<span class="built_in">semop</span>(sem_id, &amp;sop, <span class="number">1</span>);<span class="comment">//V操作</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, GETVAL));</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//共享内存段分离</span></span><br><span class="line">		<span class="built_in">shmdt</span>(pStu);</span><br><span class="line">		<span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="进程间通信：消息队列"><a href="#进程间通信：消息队列" class="headerlink" title="进程间通信：消息队列"></a>进程间通信：消息队列</h4><p><strong>消息队列</strong>提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道FIFO一样，每个数据块都有一个最大长度的限制。</p>
<p>1️⃣ <code>msgget</code>函数  创建和访问一个消息队列   在示例中，子进程和父进程都有</p>
<p>2️⃣ <code>msgsnd</code>函数  用来把消息添加到队列</p>
<p>3️⃣ <code>msgrcv</code>函数  用来从一个消息队列获取消息</p>
<p>4️⃣ <code>msgctl</code> 函数 用来控制消息队列，它与共享内存的<code>shmctl</code>函数类似，删除消息队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession92</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// msg 的接受</span></span><br><span class="line">		<span class="comment">// 有的linux系统无法实现</span></span><br><span class="line">		<span class="type">int</span> msg_id = <span class="built_in">msgget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">3</span>), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, msg_id, errno);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">		<span class="keyword">if</span> (msg_id == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">		MSG msg;</span><br><span class="line">		<span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="built_in">sizeof</span>(msg));</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//msgrcv 函数的参数依次为：消息队列 ID、接收消息的缓冲区、消息数据部分的大小、期望接收的消息类型（这里为 1）、接收标志（这里为 0）。</span></span><br><span class="line">			<span class="type">ssize_t</span> ret = <span class="built_in">msgrcv</span>(msg_id, &amp;msg, <span class="built_in">sizeof</span>(msg.data), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d name: %s age: %d msg: %s\n&quot;</span>,</span><br><span class="line">			msg.data.id, msg.data.name, msg.data.age, msg.data.message);</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="built_in">msgctl</span>(msg_id, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> msg_id = <span class="built_in">msgget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">3</span>), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">		MSG msg;</span><br><span class="line">		<span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="built_in">sizeof</span>(msg));</span><br><span class="line">		msg.type = <span class="number">1</span>;</span><br><span class="line">		msg.data.id = <span class="number">6666</span>;</span><br><span class="line">		<span class="built_in">strcpy</span>(msg.data.name, <span class="string">&quot;Bingo&quot;</span>);</span><br><span class="line">		msg.data.age = <span class="number">18</span>;</span><br><span class="line">		<span class="built_in">strcpy</span>(msg.data.message, <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;***%d name: %s age: %d msg: %s\n&quot;</span>,</span><br><span class="line">			msg.data.id, msg.data.name, msg.data.age, msg.data.message);</span><br><span class="line">		<span class="comment">//msgsnd 函数将消息发送到消息队列</span></span><br><span class="line">		<span class="built_in">msgsnd</span>(msg_id, &amp;msg, <span class="built_in">sizeof</span>(msg.data), <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//使用 msgctl 函数删除消息队列。</span></span><br><span class="line">		<span class="built_in">msgctl</span>(msg_id, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>待续。。。。</p>
]]></content>
      <categories>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程05-IO复用</title>
    <url>/2025/01/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B05-IO%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h3 id="select模型以及实战案例"><a href="#select模型以及实战案例" class="headerlink" title="select模型以及实战案例"></a>select模型以及实战案例</h3><p><strong>复用的概念：为了提高物理设备的效率，用最少的物理要素传递 ，最少数据时使用的技术</strong></p>
<p><strong>多进程服务器的缺点和解决办法</strong></p>
<p>多进程服务器：1、需要大量的运算        2、大量的内存空间</p>
<p><strong>理解select函数并实现服务端</strong></p>
<p>1、是否存在套接字接收数据？</p>
<p>2、无需阻塞传输数据的套接字有哪些？</p>
<p>3、哪些套接字发生了异常？</p>
<p><strong>Select模型具体步骤</strong></p>
<p><img src="https://bu.dusays.com/2025/01/13/67847ba4af4fe.png"></p>
<h3 id="EPOLL-模型"><a href="#EPOLL-模型" class="headerlink" title="EPOLL 模型"></a><code>EPOLL</code> 模型</h3><p><code>**Epoll</code>的三大函数：<code>epoll_create</code>，<code>epoll_wait</code>， <code>epoll_ct</code>**</p>
<p><strong>int <code>epoll_create</code>(int size);</strong>    size必须要大于0      这个函数返回文件描述符</p>
<p> <strong><code>epoll_ctl</code></strong></p>
<h3 id="EPOOL-模型和-select-模型的对比"><a href="#EPOOL-模型和-select-模型的对比" class="headerlink" title="EPOOL 模型和 select 模型的对比"></a><code>EPOOL</code> 模型和 <code>select</code> 模型的对比</h3><ol>
<li><strong>性能方面</strong><ul>
<li>系统调用开销：<ul>
<li>在<code>select</code>模型中，每次调用<code>select</code>函数时，都需要将用户空间的文件描述符集合拷贝到内核空间。当文件描述符数量较多时，这种拷贝操作会带来较大的开销。例如，在一个有大量并发连接的服务器场景中，如果有 1000 个文件描述符，每次<code>select</code>调用都要拷贝这 1000 个文件描述符相关的信息。</li>
<li>而<code>epoll</code>使用了内核与用户空间共享的数据结构。<code>epoll_create</code>创建<code>epoll</code>实例后，<code>epoll_ctl</code>函数用于在内核维护的红黑树中添加、删除或修改文件描述符及其对应的事件。在<code>epoll_wait</code>调用时，不需要像<code>select</code>那样频繁地拷贝大量文件描述符集合，减少了系统调用的开销。</li>
</ul>
</li>
<li>事件触发方式的效率：<ul>
<li><code>select</code>模型采用的是水平触发（Level - Triggered）方式。这意味着只要文件描述符对应的缓冲区中有数据可读或者可写，<code>select</code>就会一直通知应用程序该文件描述符可读或可写。例如，在处理网络套接字时，如果应用程序没有及时处理完缓冲区中的数据，<code>select</code>在下一次调用时仍然会通知该套接字可读，这可能导致一些不必要的重复处理。</li>
<li><code>epoll</code>可以采用边缘触发（Edge - Triggered）方式（如代码中设置<code>EPOLLET</code>）。边缘触发是在文件描述符状态发生变化（如从不可读到可读，或者从不可写到可写）的瞬间触发事件通知。这样，只有当有新的数据到来或者连接状态真正改变时才会触发事件，避免了像<code>select</code>那样因为缓冲区数据未处理完而导致的重复通知，从而提高了处理效率。</li>
</ul>
</li>
</ul>
</li>
<li><strong>可扩展性方面</strong><ul>
<li>文件描述符数量限制：<ul>
<li><code>select</code>模型对文件描述符数量有比较严格的限制。在不同的操作系统中，这个限制可能不同，但通常是一个较小的固定值。例如，在一些旧版本的 Unix 系统中，<code>select</code>最多能处理 1024 个文件描述符。这在处理大量并发连接的现代网络应用场景中是远远不够的。</li>
<li><code>epoll</code>没有这种固定的、较小的文件描述符数量限制。它可以处理的文件描述符数量主要取决于系统的资源（如内存大小等）。这使得<code>epoll</code>能够更好地适应高并发场景，如大型的 Web 服务器或者消息队列服务器，这些服务器可能需要同时处理成千上万个客户端连接。</li>
</ul>
</li>
</ul>
</li>
<li><strong>代码复杂度方面</strong><ul>
<li>事件处理的代码逻辑：<ul>
<li>在<code>select</code>模型中，应用程序需要遍历所有的文件描述符来检查哪些文件描述符产生了事件。例如，每次<code>select</code>返回后，需要在一个循环中逐个检查文件描述符集合中的每个文件描述符是否在可读或可写集合中。如果文件描述符数量较多，这种遍历检查的代码会比较复杂且效率低下。</li>
<li><code>epoll</code>返回的是已经发生事件的文件描述符集合，应用程序只需要直接处理这些发生事件的文件描述符即可。在代码逻辑上，<code>epoll</code>更加简洁明了，不需要像<code>select</code>那样进行大量的遍历和判断操作，降低了代码的复杂度和出错的概率。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="边缘触发和条件触发"><a href="#边缘触发和条件触发" class="headerlink" title="边缘触发和条件触发"></a>边缘触发和条件触发</h3><p><strong>条件触发(level-triggered，也被称为水平触发)LT:</strong> </p>
<p>只要满足条件，就触发一个事件(只要有数据没有被获取，内核就不断通知你)</p>
<p> <strong>边缘触发(edge-triggered)ET:</strong> </p>
<p>每当状态变化时，触发一个事件<br> “举个读socket的例子，假定经过长时间的沉默后，现在来了100个字节，这时无论边缘触发和条件触发都会产生一个通知应用程序可读。应用程序读了50个字节，然后重新调用<code>api</code>等待<code>io</code>事件。</p>
<p>这时水平触发的<code>api</code>会因为还有50个字节可读从而立即返回用户一个read ready notification。</p>
<p>而边缘触发的<code>api</code>会因为可读这个状态没有发生变化而陷入长期等待。 因此在使用边缘触发的<code>api</code>时，要注意每次都要读到socket返回<code>EWOULDBLOCK</code>为止，否则这个socket就算废了。而使用条件触发的<code>api</code> 时，如果应用程序不需要写就不要关注socket可写的事件，否则就会无限次的立即返回一个write ready notification。</p>
<p>select属于典型的条件触发。</p>
]]></content>
      <categories>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程06-Makefile相关知识</title>
    <url>/2025/01/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B06-Makefile%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows系统编程01</title>
    <url>/2025/02/05/Windows%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>从整体上看待这个技术</p>
]]></content>
      <categories>
        <category>Windows系统编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm00算法遇到的问题</title>
    <url>/2024/12/11/algorithm00%E7%AE%97%E6%B3%95%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>输入字符</strong></p>
<p>scanf函数是标准输入流（从键盘接收数据)，接收的数据放入输入缓冲区中，其中就包括在键盘输入的空格、回车这类字符，当你用%d接收时是不会影响的，但是用%c就会产生错误，这是因为在”%c”输入时，空格和转义字符均作为有效字符会被%c接收。</p>
<p>解决方法1：scanf() 前面加上getchar()清除缓存区的\n</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确做法</span></span><br><span class="line"><span class="type">char</span> op;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;op);</span><br></pre></td></tr></table></figure>

<p>解决方法2：在%c之前 加上空格，空格 可以吸收回车符号、空格。建议使用”,“进行隔开，并且在键盘输入的时候也要使用”,”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> op;</span><br><span class="line"><span class="type">char</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;op);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c %c %c&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c,%c,%c&quot;</span>,a,b,c);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程02-基础知识一客户端服务器端模型</title>
    <url>/2025/01/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B02-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="简单的TCP-客户端-服务器模型"><a href="#简单的TCP-客户端-服务器模型" class="headerlink" title="简单的TCP 客户端 - 服务器模型"></a>简单的TCP 客户端 - 服务器模型</h3><h4 id="run-client函数"><a href="#run-client函数" class="headerlink" title="run_client函数"></a><code>run_client</code>函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_client</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个TCP套接字</span></span><br><span class="line">    <span class="type">int</span> client = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    PF_INET 指定协议族为 IPv4</span></span><br><span class="line"><span class="comment">    SOCK_STREAM：指定套接字类型为流套接字</span></span><br><span class="line"><span class="comment">    0：指定协议类型，这里使用默认协议</span></span><br><span class="line"><span class="comment">    如果socket函数成功创建套接字，会返回一个非负整数作为套接字描述符；如果失败，返回-1。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 定义一个struct sockaddr_in类型的变量addr，用于存储地址信息。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务器地址结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定地址族为 IPv4，AF代表 “Address Family”，AF_INET和前面的PF_INET相对应。</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 设置服务器IP地址为本地回环地址127.0.0.1</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置服务器端口号为9527</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="comment">// 将客户端套接字（client）连接到指定的服务器地址（servaddr）。</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(client, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    <span class="comment">// 连接成功，ret的值为 0；如果连接失败，ret的值为 -1，并且会设置相应的错误码。</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出当前文件、行号和函数名，表示连接成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;hello,hello\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 向服务器发送消息</span></span><br><span class="line">        <span class="comment">// client是套接字描述符，buffer是要发送的数据缓冲区，sizeof(buffer)表示要发送的数据长度。</span></span><br><span class="line">        <span class="built_in">write</span>(client, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">// 清空缓冲区</span></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">// 从服务器读取响应</span></span><br><span class="line">        <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">// 输出服务器的响应</span></span><br><span class="line">        std::cout &lt;&lt; buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 输出连接失败的错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">    <span class="comment">// 输出客户端完成信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client done!!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="run-server-函数"><a href="#run-server-函数" class="headerlink" title="run_server()函数"></a><code>run_server()</code>函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession63_</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> server, client;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> seraddr, clientaddr;</span><br><span class="line">    <span class="type">socklen_t</span> cliaddrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个TCP套接字</span></span><br><span class="line">    server = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (server &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 输出错误信息并返回</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;error！！\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化服务器地址结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置地址族为IPv4</span></span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 服务器绑定到所有网络接口上</span></span><br><span class="line">    seraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置服务器端口号为9527</span></span><br><span class="line">    seraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将套接字绑定到指定地址和端口</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出绑定失败信息并关闭套接字</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bind failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听连接，最大连接数为3</span></span><br><span class="line">    <span class="comment">// 使用listen函数使服务器套接字server开始监听传入的连接请求，最大允许连接数为 3。</span></span><br><span class="line">    <span class="comment">// listen函数返回 0 表示成功，返回 -1 表示失败。</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(server, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出监听失败信息并关闭套接字</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;listen failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 清空缓冲区</span></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">// 输出当前文件、行号和函数名</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="comment">// 接受客户端连接</span></span><br><span class="line">        client = <span class="built_in">accept</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;cliaddrlen);</span><br><span class="line">        <span class="keyword">if</span> (client == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 输出接受客户端连接失败信息并关闭服务器</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;client failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(server);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出当前文件、行号和函数名</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="comment">// 从客户端读取消息</span></span><br><span class="line">        <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">// 将接收到的消息回显给客户端</span></span><br><span class="line">        <span class="type">ssize_t</span> len = <span class="built_in">write</span>(client, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (len!= (<span class="type">ssize_t</span>)<span class="built_in">strlen</span>(buffer))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 输出写回显失败信息并关闭服务器</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;write failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(server);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出当前文件、行号和函数名</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="comment">// 关闭与客户端的连接</span></span><br><span class="line">        <span class="built_in">close</span>(client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭服务器套接字</span></span><br><span class="line">    <span class="built_in">close</span>(server);</span><br><span class="line">    <span class="comment">// 输出当前文件、行号和函数名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lession63-函数"><a href="#lession63-函数" class="headerlink" title="lession63()函数"></a><code>lession63()</code>函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession63</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程，作为客户端运行</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 运行客户端函数两次</span></span><br><span class="line">        <span class="built_in">run_client</span>();</span><br><span class="line">        <span class="built_in">run_client</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程，作为服务器端运行</span></span><br><span class="line">        <span class="built_in">lession63_</span>();</span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 等待子进程结束</span></span><br><span class="line">        <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 输出fork失败信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fork failed!&quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>客户端的流程</strong></p>
<p>1️⃣创建套接字</p>
<p>2️⃣初始化服务器地址</p>
<p>3️⃣连接服务器。connect 成功返回0，失败返回-1</p>
<p>4️⃣通信   write read</p>
<p>5️⃣关闭套接字 （close关闭）</p>
<p><strong>服务器的流程</strong></p>
<p>1️⃣创建套接字</p>
<p>2️⃣初始化服务器地址</p>
<p>3️⃣绑定套接字，<code>bind</code> 函数将服务器套接字 <code>server</code> 绑定到指定的地址和端口。</p>
<p>4️⃣监听连接，<code>listen</code>函数使得服务器套接字开始监听传入的连接请求</p>
<p>5️⃣接受并处理客户端连接，返回一个新的套接字描述符用于与客户端通信。   read、write 处理完客户端请求后，使用 <code>close</code> 函数关闭与客户端的连接。</p>
<p>6️⃣关闭服务器套接字，<code>close(server)</code></p>
<h4 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h4><p><strong>客户端设置服务器地址</strong></p>
<p>客户端设置服务器地址是为了明确要连接的目标服务器位置。它通过<code>struct sockaddr_in</code>结构体来存储服务器的网络地址信息，包括 <code>IP</code> 地址和端口号。</p>
<p><strong>服务器端设置服务器地址</strong></p>
<p>服务器端设置自己的地址主要是为了将服务器套接字绑定到一个特定的网络接口和端口上，以便接收来自客户端的连接请求。</p>
<p><strong><code>connect()</code>函数  和  <code>bind()</code>函数   的区别</strong></p>
<ul>
<li><p><code>connect</code>函数主要用于客户端套接字与服务器端套接字建立连接。它尝试将客户端的网络端点（由 IP 地址和端口号标识）与服务器的网络端点进行关联，从而建立起一条通信链路，使得客户端和服务器可以互相发送和接收数据。</p>
</li>
<li><p><code>bind</code>函数主要用于服务器端将套接字绑定到一个特定的本地网络端点（包括 IP 地址和端口号）。它的作用是让服务器在特定的网络地址和端口上监听客户端的连接请求，使得客户端能够准确地找到服务器并与之建立连接。</p>
</li>
</ul>
<p><strong>这俩部分设置是否一样？</strong></p>
<ul>
<li>客户端角度<ul>
<li>客户端设置的服务器 IP 地址必须是服务器实际绑定并监听的 IP 地址之一。如果服务器绑定了特定的 IP 地址（例如<code>192.168.1.100</code>），客户端就需要使用这个 IP 地址来连接服务器。不过，如果服务器绑定的是<code>0.0.0.0</code>（表示监听所有本地网络接口），客户端可以使用服务器所在主机的任何一个有效本地 IP 地址来连接。</li>
</ul>
</li>
<li>服务器角度<ul>
<li>服务器绑定的 IP 地址决定了它在哪些网络接口上监听客户端连接。如果服务器有多个网络接口（例如有多个网卡，每个网卡有不同的 IP 地址），绑定<code>0.0.0.0</code>意味着在所有接口上监听；而绑定特定的 IP 地址则只在该接口监听。</li>
</ul>
</li>
</ul>
<h3 id="简单的-UDP-客户端-服务器模型"><a href="#简单的-UDP-客户端-服务器模型" class="headerlink" title="简单的 UDP 客户端 - 服务器模型"></a>简单的 <code>UDP</code> 客户端 - 服务器模型</h3><h4 id="server-函数"><a href="#server-函数" class="headerlink" title="server()函数"></a><code>server</code>()函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">server</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ser_sock = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">char</span> message[<span class="number">512</span>];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr, clientaddr;</span><br><span class="line">	<span class="type">socklen_t</span> clientlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查命令行参数</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s  &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">handle_error</span>(<span class="string">&quot;argement is error!:&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建UDP套接字</span></span><br><span class="line">	ser_sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>); <span class="comment">// UDP</span></span><br><span class="line">	<span class="keyword">if</span> (ser_sock == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">handle_error</span>(<span class="string">&quot;create socket failed:&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    <span class="comment">// 初始化服务器地址</span></span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 0.0.0.0  全网段监听</span></span><br><span class="line">    <span class="comment">// 设置servaddr的端口号为从命令行参数argv[1]中获取的端口号</span></span><br><span class="line">    <span class="comment">// 通过htons函数将其转换为网络字节序。</span></span><br><span class="line">	servaddr.sin_port = <span class="built_in">htons</span>((<span class="type">short</span>)<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定套接字到地址</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">bind</span>(ser_sock, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">handle_error</span>(<span class="string">&quot;bind failed:&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 消息处理循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用recvfrom函数从客户端接收数据</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        ser_sock：服务器套接字描述符。</span></span><br><span class="line"><span class="comment">        0：表示默认的标志位。</span></span><br><span class="line"><span class="comment">        (struct sockaddr*)&amp;clientaddr：用于存储客户端地址的结构体指针。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        recvfrom 函数返回接收到的数据长度。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="type">ssize_t</span> len = <span class="built_in">recvfrom</span>(ser_sock, message, <span class="built_in">sizeof</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用sendto函数将接收到的数据回显给客户端</span></span><br><span class="line">		<span class="built_in">sendto</span>(ser_sock, message, len, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, clientlen);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">	<span class="built_in">close</span>(ser_sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="client-函数"><a href="#client-函数" class="headerlink" title="client()函数"></a><code>client()</code>函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">client</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 变量声明</span></span><br><span class="line">	<span class="type">int</span> client_sock;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">	<span class="type">socklen_t</span> serv_len = <span class="built_in">sizeof</span>(serv_addr);</span><br><span class="line">	<span class="type">char</span> message[<span class="number">512</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s is port\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">handle_error</span>(<span class="string">&quot;argement error:&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 创建 UDP 套接字</span></span><br><span class="line">    <span class="comment">// UDP 套接字是无连接的，通过SOCK_DGRAM参数来指定创建 UDP 类型的套接字。</span></span><br><span class="line">	client_sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (client_sock == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">handle_error</span>(<span class="string">&quot;socket create failed！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="comment">// 初始化服务器地址</span></span><br><span class="line">	serv_addr.sin_family = AF_INET;</span><br><span class="line">	serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">	serv_addr.sin_port = <span class="built_in">htons</span>((<span class="type">short</span>)<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息处理循环</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Input message(q to quit):&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, message);</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">strcmp</span>(message, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q&quot;</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 分配了地址</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">		<span class="type">ssize_t</span> len = <span class="built_in">sendto</span>(client_sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (sockaddr*)&amp;serv_addr, serv_len);</span><br><span class="line">		<span class="built_in">memset</span>(message, <span class="number">0</span>, len);</span><br><span class="line">		<span class="built_in">recvfrom</span>(client_sock, message, <span class="built_in">sizeof</span>(message), <span class="number">0</span>, (sockaddr*)&amp;serv_addr, &amp;serv_len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;recv:%s\n&quot;</span>, message);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 关闭套接字并返回</span></span><br><span class="line">	<span class="built_in">close</span>(client_sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><strong><code>UDP</code>客户端的流程</strong></p>
<p>1️⃣创建套接字</p>
<p>2️⃣设置服务器地址端口</p>
<p>3️⃣使用<code>sendto</code>函数发送数据、<code>recvfrom</code>函数来接收数据。</p>
<p>4️⃣关闭套接字</p>
<p><strong><code>UDP</code>服务器端的流程</strong></p>
<p>1️⃣创建套接字</p>
<p>2️⃣绑定地址和端口</p>
<p>3️⃣接受、处理数据</p>
<p>4️⃣ 关闭套接字</p>
<h4 id="问题汇总-1"><a href="#问题汇总-1" class="headerlink" title="问题汇总"></a>问题汇总</h4><p><code>UDP</code>服务器端&#x2F;客户端的实现方法。但如果仔细观察<code>UDP</code>客户端会发现，它缺少把<code>IP</code>和端口分配给套接字的过程。</p>
<p><code>TCP</code>客户端调用connect函数自动完成此过程，<code>UDP</code>调用<code>sendto</code>函数时自动分配<code>IP</code>和端口号</p>
<p><strong>套接字类型只能在创建时决定，以后不能再更改。</strong></p>
<p><strong><code>SO_SNDBUF &amp;SO_RCVBUF</code></strong></p>
<p><code>SO_RCVBUF</code>是输入缓冲大小相关可选项，<code>SO_SNDBUF</code>是输出缓冲大小相关可选项。用这2 个可选项既可以读取当前I&#x2F;O缓冲大小，也可以进行更改。通过下列示例读取创建套接字时默认的I&#x2F;O缓冲大小。</p>
<p><strong>如何使用<code>socket</code>、<code>getsockopt</code>和<code>setsockopt</code>函数来获取和设置套接字的属性</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession76</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明了两个整数变量，分别用于存储 TCP 套接字描述符和 UDP 套接字描述符。</span></span><br><span class="line">	<span class="type">int</span> tcp_sock, udp_sock;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明并初始化一个整数变量optval，用于存储套接字选项的值。</span></span><br><span class="line">	<span class="type">int</span> optval = <span class="number">0</span>;</span><br><span class="line">	<span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(optval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别创建TCP/UDP 套接字</span></span><br><span class="line">	tcp_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	udp_sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;SOCK_STREAM:%d\n&quot;</span>, SOCK_STREAM);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;SOCK_DGRAM:%d\n&quot;</span>, SOCK_DGRAM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取套接字类型</span></span><br><span class="line">    <span class="comment">// 使用getsockopt函数获取 TCP 套接字的类型。</span></span><br><span class="line">    <span class="comment">// SOL_SOCKET表示通用套接字选项级别，SO_TYPE表示要获取的选项是套接字类型。</span></span><br><span class="line">    <span class="comment">// 获取到的值存储在optval中。</span></span><br><span class="line">	<span class="built_in">getsockopt</span>(tcp_sock, SOL_SOCKET, SO_TYPE, (<span class="type">void</span>*)&amp;optval, &amp;len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tcp_sock type is :%d\n&quot;</span>, optval);</span><br><span class="line">	optval = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">getsockopt</span>(udp_sock, SOL_SOCKET, SO_TYPE, (<span class="type">void</span>*)&amp;optval, &amp;len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;udp_sock type is :%d\n&quot;</span>, optval);</span><br><span class="line">	optval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取和设置 TCP 套接字发送缓冲区大小</span></span><br><span class="line">	<span class="built_in">getsockopt</span>(tcp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;optval, &amp;len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tcp_sock send buffer size is :%d\n&quot;</span>, optval);</span><br><span class="line">	optval = <span class="number">1024</span> * <span class="number">16</span>;</span><br><span class="line">	<span class="built_in">setsockopt</span>(tcp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;optval, len);</span><br><span class="line">	<span class="built_in">getsockopt</span>(tcp_sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;optval, &amp;len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*tcp_sock send buffer size is :%d\n&quot;</span>, optval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">	<span class="built_in">close</span>(tcp_sock);</span><br><span class="line">	<span class="built_in">close</span>(udp_sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>僵尸进程</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession82</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 父进程睡眠30秒  给子进程足够的时间来执行。</span></span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">30</span>);</span><br><span class="line">		<span class="type">int</span> status;</span><br><span class="line">		<span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>信号处理函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_func</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (sig)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> SIGALRM:  <span class="comment">// 闹钟信号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tid %d pid %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">alarm</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SIGINT:   <span class="comment">// 通常由用户按下 Ctrl + C 产生</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ctrl + C press...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession83</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打印当前的线程id和  进程id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=====tid %d pid %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), <span class="built_in">getpid</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把signal_func函数分别注册为SIGALRM信号、SIGINT信号的处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM, signal_func);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signal_func);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 alarm(1) 设置一个 1 秒的闹钟，1 秒后会触发 SIGALRM 信号。</span></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=====tid %d pid %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), <span class="built_in">getpid</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm01数据结构算法</title>
    <url>/2024/12/11/algorithm01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>堆三种操作：</p>
<p>1.插入一个数   2.求集合当中的最小值   3.删除最小值  4.删除任意一个元素   5.修改任意一个元素</p>
<p>堆是一颗完全二叉树 </p>
<p> 小根堆 ：每个点都是小于等于左右儿子的</p>
<p>堆的存储：使用一个一维数组来存储的</p>
<p>堆有俩操作：down 和 up   （调整）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加  删除</span></span><br><span class="line">heap[++ size] = x; <span class="built_in">up</span>(size);</span><br><span class="line">heap[<span class="number">1</span>];</span><br><span class="line">heap[<span class="number">1</span>] = heap[size];</span><br><span class="line">size --;</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//删除任意元素</span></span><br><span class="line">heap[k] = heap[size];</span><br><span class="line">size--;</span><br><span class="line"><span class="built_in">down</span>(k); </span><br><span class="line"><span class="built_in">up</span>(k);</span><br><span class="line"><span class="comment">//修改元素</span></span><br><span class="line">heap[k] = x;</span><br><span class="line"><span class="built_in">down</span>(k); </span><br><span class="line"><span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= num &amp;&amp;  h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= num &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    num = n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i-- ) <span class="built_in">down</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>] = h[num];</span><br><span class="line">        num -- ;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">int h[N], ph[N], hp[N], cnt;</span><br><span class="line"></span><br><span class="line">void heap_swap(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    swap(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    swap(hp[a], hp[b]);</span><br><span class="line">    swap(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void down(int u)</span><br><span class="line">&#123;</span><br><span class="line">    int t = u;</span><br><span class="line">    if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;</span><br><span class="line">    if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;</span><br><span class="line">    if (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, t);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void up(int u)</span><br><span class="line">&#123;</span><br><span class="line">    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])</span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, u / 2);</span><br><span class="line">        u &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m = 0;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    while (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        char op[5];</span><br><span class="line">        int k, x;</span><br><span class="line">        scanf(&quot;%s&quot;, op);</span><br><span class="line">        if (!strcmp(op, &quot;I&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            m ++ ;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            up(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!strcmp(op, &quot;PM&quot;)) printf(&quot;%d\n&quot;, h[1]);</span><br><span class="line">        else if (!strcmp(op, &quot;DM&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            heap_swap(1, cnt);</span><br><span class="line">            cnt -- ;</span><br><span class="line">            down(1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!strcmp(op, &quot;D&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            heap_swap(k, cnt);</span><br><span class="line">            cnt -- ;</span><br><span class="line">            up(k);</span><br><span class="line">            down(k);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            up(k);</span><br><span class="line">            down(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    <span class="comment">// 将当前位置idx的下一个元素的索引存储到ne数组中。</span></span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N ) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>词根词缀01</title>
    <url>/2025/01/22/%E8%AF%8D%E6%A0%B9%E8%AF%8D%E7%BC%8001/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>前缀–方向</th>
</tr>
</thead>
<tbody><tr>
<td>1️⃣外&#x2F;出 e&#x2F;ex&#x2F;ef  export 出口<br />2️⃣内&#x2F;进 in&#x2F;im   inject 注射<br />3️⃣前<br />(1)动态-向前：pro –progress  进步<br />(2)静态-在前&#x2F;预先&#x2F;提前：pre –prepare  准备<br />4️⃣回&#x2F;重新&#x2F;再次：re-return–返回  recede–退朝&#x2F;衰退<br />5️⃣聚集(一起&#x2F;共同)：co&#x2F;con&#x2F;com&#x2F;col<br />6️⃣分散(分开)：di&#x2F;dis&#x2F;dif–divorce   离婚 divide 分成<br />  distribute 分配   distract  分开 <br />7️⃣上&#x2F;超过：super&#x2F;over&#x2F;sur   surrealism   超现实主义<br />surpass 超过<br />8️⃣ 下&#x2F;不足：under&#x2F;de&#x2F;sub&#x2F;sup –decrease   degrade  <br />9️⃣转移&#x2F;转变：trans&#x2F;-transfer 转账  转会  换乘 <br />🔟相互之间 inter–internet<br />⑪ a + 双写辅音字母 &#x3D; 强调&#x2F;无意义<br />⑫否定前缀：un  mis  im in  ab  dis   il</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>后缀（3）–词性</th>
</tr>
</thead>
<tbody><tr>
<td>1️⃣动词后缀  ate（90%）  ize  ify  ish</td>
</tr>
<tr>
<td>2️⃣形容词后缀：ent&#x2F;ful&#x2F;ous&#x2F;al&#x2F;ive&#x2F;ible&#x2F;able&#x2F;ant</td>
</tr>
<tr>
<td>3️⃣名词后缀：lon&#x2F;tion&#x2F;ation&#x2F;ness&#x2F;ity&#x2F;ality&#x2F;ment&#x2F;ence&#x2F;ance&#x2F;ism</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>词根–意思</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>pose<br />form<br />Norm<br />vis<br />leg<br />ceed<br />duce<br />claim<br />verse<br />vade<br />gress<br />vent<br />ject<br />lect<br />spect<br />press</td>
<td>sense<br />valu<br />sim<br />tain<br />serve<br />view<br />tract<br />nov<br />radi<br />rupt<br />dict<br />fer<br />clude<br />flu<br />scribe<br />dens</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm02哈希表</title>
    <url>/2025/01/21/algorithm02%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
